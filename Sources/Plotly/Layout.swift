
// Warning: This file is automatically generated and your changes will be overwritten.
// See `Sources/Codegen/Readme.md` for more details.


/// Specification of element arrangement on a `Figure` that applies to all traces.
/// 
/// - SeeAlso:
///   Documentation for 
///   [Python](https://plot.ly/python/reference/#layout), 
///   [JavaScript](https://plot.ly/javascript/reference/#layout) or 
///   [R](https://plot.ly/r/reference/#layout)
public struct Layout: Encodable {
    
    // MARK: FunnelArea

    /// Sets the default funnelarea slice colors.
    /// 
    /// Defaults to the main `colorway` used for trace colors. If you specify a new list here it can
    /// still be extended with lighter and darker colors, see `extendfunnelareacolors`.
    public var funnelAreaColorWay: ColorList? = nil

    /// If `true`, the funnelarea slice colors (whether given by `funnelareacolorway` or inherited from
    /// `colorway`) will be extended to three times its original length by first repeating every color
    /// 20% lighter then each color 20% darker.
    /// 
    /// This is intended to reduce the likelihood of reusing the same color when you have many slices,
    /// but you can set `false` to disable. Colors provided in the trace, using `marker.colors`, are
    /// never extended.
    public var extendFunnelAreaColors: Bool? = nil

    
    // MARK: Treemap

    /// Sets the default treemap slice colors.
    /// 
    /// Defaults to the main `colorway` used for trace colors. If you specify a new list here it can
    /// still be extended with lighter and darker colors, see `extendtreemapcolors`.
    public var treemapColorWay: ColorList? = nil

    /// If `true`, the treemap slice colors (whether given by `treemapcolorway` or inherited from
    /// `colorway`) will be extended to three times its original length by first repeating every color
    /// 20% lighter then each color 20% darker.
    /// 
    /// This is intended to reduce the likelihood of reusing the same color when you have many slices,
    /// but you can set `false` to disable. Colors provided in the trace, using `marker.colors`, are
    /// never extended.
    public var extendTreemapColors: Bool? = nil

    
    // MARK: Sunburst

    /// Sets the default sunburst slice colors.
    /// 
    /// Defaults to the main `colorway` used for trace colors. If you specify a new list here it can
    /// still be extended with lighter and darker colors, see `extendsunburstcolors`.
    public var sunburstColorWay: ColorList? = nil

    /// If `true`, the sunburst slice colors (whether given by `sunburstcolorway` or inherited from
    /// `colorway`) will be extended to three times its original length by first repeating every color
    /// 20% lighter then each color 20% darker.
    /// 
    /// This is intended to reduce the likelihood of reusing the same color when you have many slices,
    /// but you can set `false` to disable. Colors provided in the trace, using `marker.colors`, are
    /// never extended.
    public var extendSunburstColors: Bool? = nil

    
    // MARK: Pie

    /// hiddenlabels is the funnelarea & pie chart analog of visible:'legendonly' but it can contain
    /// many labels, and can simultaneously hide slices from several pies/funnelarea charts
    public var hiddenLabels: [Double]? = nil

    /// Sets the default pie slice colors.
    /// 
    /// Defaults to the main `colorway` used for trace colors. If you specify a new list here it can
    /// still be extended with lighter and darker colors, see `extendpiecolors`.
    public var pieColorWay: ColorList? = nil

    /// If `true`, the pie slice colors (whether given by `piecolorway` or inherited from `colorway`)
    /// will be extended to three times its original length by first repeating every color 20% lighter
    /// then each color 20% darker.
    /// 
    /// This is intended to reduce the likelihood of reusing the same color when you have many slices,
    /// but you can set `false` to disable. Colors provided in the trace, using `marker.colors`, are
    /// never extended.
    public var extendPieColors: Bool? = nil

    
    // MARK: Waterfall

    /// Determines how bars at the same location coordinate are displayed on the graph.
    /// 
    /// With *group*, the bars are plotted next to one another centered around the shared location. With
    /// *overlay*, the bars are plotted over one another, you might need to an *opacity* to see multiple
    /// bars.
    public enum WaterfallMode: String, Encodable {
        case group
        case overlay
    }
    /// Determines how bars at the same location coordinate are displayed on the graph.
    /// 
    /// With *group*, the bars are plotted next to one another centered around the shared location. With
    /// *overlay*, the bars are plotted over one another, you might need to an *opacity* to see multiple
    /// bars.
    public var waterfallMode: WaterfallMode? = nil

    /// Sets the gap (in plot fraction) between bars of adjacent location coordinates.
    public var waterfallGap: Double? = nil

    /// Sets the gap (in plot fraction) between bars of the same location coordinate.
    public var waterfallGroupGap: Double? = nil

    
    // MARK: Funnel

    /// Determines how bars at the same location coordinate are displayed on the graph.
    /// 
    /// With *stack*, the bars are stacked on top of one another With *group*, the bars are plotted next
    /// to one another centered around the shared location. With *overlay*, the bars are plotted over
    /// one another, you might need to an *opacity* to see multiple bars.
    public enum FunnelMode: String, Encodable {
        case stack
        case group
        case overlay
    }
    /// Determines how bars at the same location coordinate are displayed on the graph.
    /// 
    /// With *stack*, the bars are stacked on top of one another With *group*, the bars are plotted next
    /// to one another centered around the shared location. With *overlay*, the bars are plotted over
    /// one another, you might need to an *opacity* to see multiple bars.
    public var funnelMode: FunnelMode? = nil

    /// Sets the gap (in plot fraction) between bars of adjacent location coordinates.
    public var funnelGap: Double? = nil

    /// Sets the gap (in plot fraction) between bars of the same location coordinate.
    public var funnelGroupGap: Double? = nil

    
    // MARK: Violin

    /// Determines how violins at the same location coordinate are displayed on the graph.
    /// 
    /// If *group*, the violins are plotted next to one another centered around the shared location. If
    /// *overlay*, the violins are plotted over one another, you might need to set *opacity* to see them
    /// multiple violins. Has no effect on traces that have *width* set.
    public enum ViolinMode: String, Encodable {
        case group
        case overlay
    }
    /// Determines how violins at the same location coordinate are displayed on the graph.
    /// 
    /// If *group*, the violins are plotted next to one another centered around the shared location. If
    /// *overlay*, the violins are plotted over one another, you might need to set *opacity* to see them
    /// multiple violins. Has no effect on traces that have *width* set.
    public var violinMode: ViolinMode? = nil

    /// Sets the gap (in plot fraction) between violins of adjacent location coordinates.
    /// 
    /// Has no effect on traces that have *width* set.
    public var violinGap: Double? = nil

    /// Sets the gap (in plot fraction) between violins of the same location coordinate.
    /// 
    /// Has no effect on traces that have *width* set.
    public var violinGroupGap: Double? = nil

    
    // MARK: Box and Candlestick

    /// Determines how boxes at the same location coordinate are displayed on the graph.
    /// 
    /// If *group*, the boxes are plotted next to one another centered around the shared location. If
    /// *overlay*, the boxes are plotted over one another, you might need to set *opacity* to see them
    /// multiple boxes. Has no effect on traces that have *width* set.
    public enum BoxMode: String, Encodable {
        case group
        case overlay
    }
    /// Determines how boxes at the same location coordinate are displayed on the graph.
    /// 
    /// If *group*, the boxes are plotted next to one another centered around the shared location. If
    /// *overlay*, the boxes are plotted over one another, you might need to set *opacity* to see them
    /// multiple boxes. Has no effect on traces that have *width* set.
    public var boxMode: BoxMode? = nil

    /// Sets the gap (in plot fraction) between boxes of adjacent location coordinates.
    /// 
    /// Has no effect on traces that have *width* set.
    public var boxGap: Double? = nil

    /// Sets the gap (in plot fraction) between boxes of the same location coordinate.
    /// 
    /// Has no effect on traces that have *width* set.
    public var boxGroupGap: Double? = nil

    
    // MARK: Bar, BarPolar and Histogram

    /// Determines how bars at the same location coordinate are displayed on the graph.
    /// 
    /// With *stack*, the bars are stacked on top of one another With *relative*, the bars are stacked
    /// on top of one another, with negative values below the axis, positive values above With *group*,
    /// the bars are plotted next to one another centered around the shared location. With *overlay*,
    /// the bars are plotted over one another, you might need to an *opacity* to see multiple bars.
    public enum BarMode: String, Encodable {
        case stack
        case group
        case overlay
        case relative
    }
    /// Determines how bars at the same location coordinate are displayed on the graph.
    /// 
    /// With *stack*, the bars are stacked on top of one another With *relative*, the bars are stacked
    /// on top of one another, with negative values below the axis, positive values above With *group*,
    /// the bars are plotted next to one another centered around the shared location. With *overlay*,
    /// the bars are plotted over one another, you might need to an *opacity* to see multiple bars.
    public var barMode: BarMode? = nil

    /// Sets the normalization for bar traces on the graph.
    /// 
    /// With *fraction*, the value of each bar is divided by the sum of all values at that location
    /// coordinate. *percent* is the same but multiplied by 100 to show percentages.
    public enum BarNormalization: String, Encodable {
        case off = ""
        case fraction
        case percent
    }
    /// Sets the normalization for bar traces on the graph.
    /// 
    /// With *fraction*, the value of each bar is divided by the sum of all values at that location
    /// coordinate. *percent* is the same but multiplied by 100 to show percentages.
    public var barNormalization: BarNormalization? = nil

    /// Sets the gap (in plot fraction) between bars of adjacent location coordinates.
    public var barGap: Double? = nil

    /// Sets the gap (in plot fraction) between bars of the same location coordinate.
    public var barGroupGap: Double? = nil

    
    // MARK: - Design, Look and Feel

    /// Sets the global font.
    /// 
    /// Note that fonts used in traces and other layout components inherit from the global font.
    public var font: Font? = nil

    public struct Title: Encodable {
        /// Sets the plot's title.
        /// 
        /// Note that before the existence of `title.text`, the title's contents used to be defined as the
        /// `title` attribute itself. This behavior has been deprecated.
        public var text: String? = nil
    
        /// Sets the title font.
        /// 
        /// Note that the title's font used to be customized by the now deprecated `titlefont` attribute.
        public var font: Font? = nil
    
        /// Sets the container `x` refers to.
        /// 
        /// *container* spans the entire `width` of the plot. *paper* refers to the width of the plotting
        /// area only.
        public enum XAxisReference: String, Encodable {
            case container
            case paper
        }
        /// Sets the container `x` refers to.
        /// 
        /// *container* spans the entire `width` of the plot. *paper* refers to the width of the plotting
        /// area only.
        public var xReference: XAxisReference? = nil
    
        /// Sets the container `y` refers to.
        /// 
        /// *container* spans the entire `height` of the plot. *paper* refers to the height of the plotting
        /// area only.
        public enum YAxisReference: String, Encodable {
            case container
            case paper
        }
        /// Sets the container `y` refers to.
        /// 
        /// *container* spans the entire `height` of the plot. *paper* refers to the height of the plotting
        /// area only.
        public var yReference: YAxisReference? = nil
    
        /// Sets the x position with respect to `xref` in normalized coordinates from *0* (left) to *1*
        /// (right).
        public var x: Double? = nil
    
        /// Sets the y position with respect to `yref` in normalized coordinates from *0* (bottom) to *1*
        /// (top).
        /// 
        /// *auto* places the baseline of the title onto the vertical center of the top margin.
        public var y: Double? = nil
    
        /// Sets the title's horizontal alignment with respect to its x position.
        /// 
        /// *left* means that the title starts at x, *right* means that the title ends at x and *center*
        /// means that the title's center is at x. *auto* divides `xref` by three and calculates the
        /// `xanchor` value automatically based on the value of `x`.
        public var xAnchor: XAutoAnchor? = nil
    
        /// Sets the title's vertical alignment with respect to its y position.
        /// 
        /// *top* means that the title's cap line is at y, *bottom* means that the title's baseline is at y
        /// and *middle* means that the title's midline is at y. *auto* divides `yref` by three and
        /// calculates the `yanchor` value automatically based on the value of `y`.
        public var yAnchor: YAutoAnchor? = nil
    
        /// Sets the padding of the title.
        /// 
        /// Each padding value only applies when the corresponding `xanchor`/`yanchor` value is set
        /// accordingly. E.g. for left padding to take effect, `xanchor` must be set to *left*. The same
        /// rule applies if `xanchor`/`yanchor` is determined automatically. Padding is muted if the
        /// respective anchor value is *middle*/*center*.
        public var padding: Padding? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case text
            case font
            case xReference = "xref"
            case yReference = "yref"
            case x
            case y
            case xAnchor = "xanchor"
            case yAnchor = "yanchor"
            case padding = "pad"
        }
        
        /// Creates `Title` object with specified properties.
        /// 
        /// - Parameters:
        ///   - text: Sets the plot's title.
        ///   - font: Sets the title font.
        ///   - xReference: Sets the container `x` refers to.
        ///   - yReference: Sets the container `y` refers to.
        ///   - x: Sets the x position with respect to `xref` in normalized coordinates from *0* (left) to *1*
        ///   (right).
        ///   - y: Sets the y position with respect to `yref` in normalized coordinates from *0* (bottom) to
        ///   *1* (top).
        ///   - xAnchor: Sets the title's horizontal alignment with respect to its x position.
        ///   - yAnchor: Sets the title's vertical alignment with respect to its y position.
        ///   - padding: Sets the padding of the title.
        public init(text: String? = nil, font: Font? = nil, xReference: XAxisReference? = nil,
                yReference: YAxisReference? = nil, x: Double? = nil, y: Double? = nil, xAnchor: XAutoAnchor? =
                nil, yAnchor: YAutoAnchor? = nil, padding: Padding? = nil) {
            self.text = text
            self.font = font
            self.xReference = xReference
            self.yReference = yReference
            self.x = x
            self.y = y
            self.xAnchor = xAnchor
            self.yAnchor = yAnchor
            self.padding = padding
        }
        
    }
    public var title: Title? = nil

    public struct UniformText: Encodable {
        /// Determines how the font size for various text elements are uniformed between each trace type.
        /// 
        /// If the computed text sizes were smaller than the minimum size defined by `uniformtext.minsize`
        /// using *hide* option hides the text; and using *show* option shows the text without further
        /// downscaling. Please note that if the size defined by `minsize` is greater than the font size
        /// defined by trace, then the `minsize` is used.
        public enum Mode: Encodable {
            case off
            case hide
            case show
            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .off:
                    try container.encode(false)
                case .hide:
                    try container.encode("hide")
                case .show:
                    try container.encode("show")
                }
            }
        }
        /// Determines how the font size for various text elements are uniformed between each trace type.
        /// 
        /// If the computed text sizes were smaller than the minimum size defined by `uniformtext.minsize`
        /// using *hide* option hides the text; and using *show* option shows the text without further
        /// downscaling. Please note that if the size defined by `minsize` is greater than the font size
        /// defined by trace, then the `minsize` is used.
        public var mode: Mode? = nil
    
        /// Sets the minimum text size between traces of the same type.
        public var minSize: Double? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case mode
            case minSize = "minsize"
        }
        
        /// Creates `UniformText` object with specified properties.
        /// 
        /// - Parameters:
        ///   - mode: Determines how the font size for various text elements are uniformed between each trace
        ///   type.
        ///   - minSize: Sets the minimum text size between traces of the same type.
        public init(mode: Mode? = nil, minSize: Double? = nil) {
            self.mode = mode
            self.minSize = minSize
        }
        
    }
    public var uniformText: UniformText? = nil

    /// Determines whether or not a layout width or height that has been left undefined by the user is
    /// initialized on each relayout.
    /// 
    /// Note that, regardless of this attribute, an undefined layout width or height is always
    /// initialized on the first call to plot.
    public var autoSize: Bool? = nil

    /// Sets the plot's width (in px).
    public var width: Double? = nil

    /// Sets the plot's height (in px).
    public var height: Double? = nil

    public struct Margin: Encodable {
        /// Sets the left margin (in px).
        public var l: Double? = nil
    
        /// Sets the right margin (in px).
        public var r: Double? = nil
    
        /// Sets the top margin (in px).
        public var t: Double? = nil
    
        /// Sets the bottom margin (in px).
        public var b: Double? = nil
    
        /// Sets the amount of padding (in px) between the plotting area and the axis lines
        public var padding: Double? = nil
    
        /// Turns on/off margin expansion computations.
        /// 
        /// Legends, colorbars, updatemenus, sliders, axis rangeselector and rangeslider are allowed to push
        /// the margins by defaults.
        public var autoExpand: Bool? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case l
            case r
            case t
            case b
            case padding = "pad"
            case autoExpand = "autoexpand"
        }
        
        /// Creates `Margin` object with specified properties.
        /// 
        /// - Parameters:
        ///   - l: Sets the left margin (in px).
        ///   - r: Sets the right margin (in px).
        ///   - t: Sets the top margin (in px).
        ///   - b: Sets the bottom margin (in px).
        ///   - padding: Sets the amount of padding (in px) between the plotting area and the axis lines
        ///   - autoExpand: Turns on/off margin expansion computations.
        public init(l: Double? = nil, r: Double? = nil, t: Double? = nil, b: Double? = nil, padding:
                Double? = nil, autoExpand: Bool? = nil) {
            self.l = l
            self.r = r
            self.t = t
            self.b = b
            self.padding = padding
            self.autoExpand = autoExpand
        }
        
    }
    public var margin: Margin? = nil

    /// Placeholder for exporting automargin-impacting values namely `margin.t`, `margin.b`, `margin.l`
    /// and `margin.r` in *full-json* mode.
    public var computed: Anything? = nil

    /// Sets the background color of the paper where the graph is drawn.
    public var paperBackgroundColor: Color? = nil

    /// Sets the background color of the plotting area in-between x and y axes.
    public var plotBackgroundColor: Color? = nil

    /// Using *strict* a numeric string in trace data is not converted to a number.
    /// 
    /// Using *convert types* a numeric string in trace data may be treated as a number during automatic
    /// axis `type` detection. This is the default value; however it could be overridden for individual
    /// axes.
    public var autoTypeNumbers: AutoTypeNumbers? = nil

    /// Sets the decimal and thousand separators.
    /// 
    /// For example, *. * puts a '.' before decimals and a space between thousands. In English locales,
    /// dflt is *.,* but other locales may alter this default.
    public var separators: String? = nil

    /// Determines whether or not a text link citing the data source is placed at the bottom-right cored
    /// of the figure.
    /// 
    /// Has only an effect only on graphs that have been generated via forked graphs from the Chart
    /// Studio Cloud (at https://chart-studio.plotly.com or on-premise).
    public var hideSources: Bool? = nil

    /// Determines whether or not a legend is drawn.
    /// 
    /// Default is `true` if there is a trace to show and any of these: a) Two or more traces would by
    /// default be shown in the legend. b) One pie trace is shown in the legend. c) One trace is
    /// explicitly given with `showlegend: true`.
    public var showLegend: Bool? = nil

    /// Sets the default trace colors.
    public var colorWay: ColorList? = nil

    
    // MARK: - Templating and Events

    /// If provided, a changed value tells `Plotly.react` that one or more data arrays has changed.
    /// 
    /// This way you can modify arrays in-place rather than making a complete new copy for an
    /// incremental change. If NOT provided, `Plotly.react` assumes that data arrays are being treated
    /// as immutable, thus any data array with a different identity from its predecessor contains new
    /// data.
    public var dataRevision: Anything? = nil

    /// Used to allow user interactions with the plot to persist after `Plotly.react` calls that are
    /// unaware of these interactions.
    /// 
    /// If `uirevision` is omitted, or if it is given and it changed from the previous `Plotly.react`
    /// call, the exact new figure is used. If `uirevision` is truthy and did NOT change, any attribute
    /// that has been affected by user interactions and did not receive a different value in the new
    /// figure will keep the interaction value. `layout.uirevision` attribute serves as the default for
    /// `uirevision` attributes in various sub-containers. For finer control you can set these
    /// sub-attributes directly. For example, if your app separately controls the data on the x and y
    /// axes you might set `xaxis.uirevision=*time*` and `yaxis.uirevision=*cost*`. Then if only the y
    /// data is changed, you can update `yaxis.uirevision=*quantity*` and the y axis range will reset
    /// but the x axis range will retain any user-driven zoom.
    public var uiRevision: Anything? = nil

    /// Controls persistence of user-driven changes in `editable: true` configuration, other than trace
    /// names and axis titles.
    /// 
    /// Defaults to `layout.uirevision`.
    public var editRevision: Anything? = nil

    /// Controls persistence of user-driven changes in selected points from all traces.
    public var selectionRevision: Anything? = nil

    /// Default attributes to be applied to the plot.
    /// 
    /// Templates can be created from existing plots using `Plotly.makeTemplate`, or created manually.
    /// They should be objects with format: `{layout: layoutTemplate, data: {[type]: [traceTemplate,
    /// ...]}, ...}` `layoutTemplate` and `traceTemplate` are objects matching the attribute structure
    /// of `layout` and a data trace. Trace templates are applied cyclically to traces of each type.
    /// Container arrays (eg `annotations`) have special handling: An object ending in `defaults` (eg
    /// `annotationdefaults`) is applied to each array item. But if an item has a `templateitemname` key
    /// we look in the template array for an item with matching `name` and apply that instead. If no
    /// matching `name` is found we mark the item invisible. Any named template item not referenced is
    /// appended to the end of the array, so you can use this for a watermark annotation or a logo
    /// image, for example. To omit one of these items on the plot, make an item with matching
    /// `templateitemname` and `visible: false`.
    public var template: Anything? = nil

    
    // MARK: - User Interface

    public struct ModeBar: Encodable {
        /// Sets the orientation of the modebar.
        public var orientation: Orientation? = nil
    
        /// Sets the background color of the modebar.
        public var backgroundColor: Color? = nil
    
        /// Sets the color of the icons in the modebar.
        public var color: Color? = nil
    
        /// Sets the color of the active or hovered on icons in the modebar.
        public var activeColor: Color? = nil
    
        /// Controls persistence of user-driven changes related to the modebar, including `hovermode`,
        /// `dragmode`, and `showspikes` at both the root level and inside subplots.
        /// 
        /// Defaults to `layout.uirevision`.
        public var uiRevision: Anything? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case orientation
            case backgroundColor = "bgcolor"
            case color
            case activeColor = "activecolor"
            case uiRevision = "uirevision"
        }
        
        /// Creates `ModeBar` object with specified properties.
        /// 
        /// - Parameters:
        ///   - orientation: Sets the orientation of the modebar.
        ///   - backgroundColor: Sets the background color of the modebar.
        ///   - color: Sets the color of the icons in the modebar.
        ///   - activeColor: Sets the color of the active or hovered on icons in the modebar.
        ///   - uiRevision: Controls persistence of user-driven changes related to the modebar, including
        ///   `hovermode`, `dragmode`, and `showspikes` at both the root level and inside subplots.
        public init(orientation: Orientation? = nil, backgroundColor: Color? = nil, color: Color? = nil,
                activeColor: Color? = nil, uiRevision: Anything? = nil) {
            self.orientation = orientation
            self.backgroundColor = backgroundColor
            self.color = color
            self.activeColor = activeColor
            self.uiRevision = uiRevision
        }
        
    }
    public var modeBar: ModeBar? = nil

    public struct NewShape: Encodable {
        public var line: DashedLine? = nil
    
        /// Sets the color filling new shapes' interior.
        /// 
        /// Please note that if using a fillcolor with alpha greater than half, drag inside the active shape
        /// starts moving the shape underneath, otherwise a new shape could be started over.
        public var fillColor: Color? = nil
    
        /// Determines the path's interior.
        /// 
        /// For more info please visit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule
        public enum FillRule: String, Encodable {
            case evenOdd = "evenodd"
            case nonZero = "nonzero"
        }
        /// Determines the path's interior.
        /// 
        /// For more info please visit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule
        public var fillRule: FillRule? = nil
    
        /// Sets the opacity of new shapes.
        public var opacity: Double? = nil
    
        /// Specifies whether new shapes are drawn below or above traces.
        public var layer: ShapeLayer? = nil
    
        /// When `dragmode` is set to *drawrect*, *drawline* or *drawcircle* this limits the drag to be
        /// horizontal, vertical or diagonal.
        /// 
        /// Using *diagonal* there is no limit e.g. in drawing lines in any direction. *ortho* limits the
        /// draw to be either horizontal or vertical. *horizontal* allows horizontal extend. *vertical*
        /// allows vertical extend.
        public enum DrawDirection: String, Encodable {
            case ortho
            case horizontal
            case vertical
            case diagonal
        }
        /// When `dragmode` is set to *drawrect*, *drawline* or *drawcircle* this limits the drag to be
        /// horizontal, vertical or diagonal.
        /// 
        /// Using *diagonal* there is no limit e.g. in drawing lines in any direction. *ortho* limits the
        /// draw to be either horizontal or vertical. *horizontal* allows horizontal extend. *vertical*
        /// allows vertical extend.
        public var drawDirection: DrawDirection? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case line
            case fillColor = "fillcolor"
            case fillRule = "fillrule"
            case opacity
            case layer
            case drawDirection = "drawdirection"
        }
        
        /// Creates `NewShape` object with specified properties.
        /// 
        /// - Parameters:
        ///   - line:
        ///   - fillColor: Sets the color filling new shapes' interior.
        ///   - fillRule: Determines the path's interior.
        ///   - opacity: Sets the opacity of new shapes.
        ///   - layer: Specifies whether new shapes are drawn below or above traces.
        ///   - drawDirection: When `dragmode` is set to *drawrect*, *drawline* or *drawcircle* this limits
        ///   the drag to be horizontal, vertical or diagonal.
        public init(line: DashedLine? = nil, fillColor: Color? = nil, fillRule: FillRule? = nil,
                opacity: Double? = nil, layer: ShapeLayer? = nil, drawDirection: DrawDirection? = nil) {
            self.line = line
            self.fillColor = fillColor
            self.fillRule = fillRule
            self.opacity = opacity
            self.layer = layer
            self.drawDirection = drawDirection
        }
        
    }
    public var newShape: NewShape? = nil

    public struct ActiveShape: Encodable {
        /// Sets the color filling the active shape' interior.
        public var fillColor: Color? = nil
    
        /// Sets the opacity of the active shape.
        public var opacity: Double? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case fillColor = "fillcolor"
            case opacity
        }
        
        /// Creates `ActiveShape` object with specified properties.
        /// 
        /// - Parameters:
        ///   - fillColor: Sets the color filling the active shape' interior.
        ///   - opacity: Sets the opacity of the active shape.
        public init(fillColor: Color? = nil, opacity: Double? = nil) {
            self.fillColor = fillColor
            self.opacity = opacity
        }
        
    }
    public var activeShape: ActiveShape? = nil

    /// Assigns extra meta information that can be used in various `text` attributes.
    /// 
    /// Attributes such as the graph, axis and colorbar `title.text`, annotation `text` `trace.name` in
    /// legend items, `rangeselector`, `updatemenus` and `sliders` `label` text all support `meta`. One
    /// can access `meta` fields using template strings: `%{meta[i]}` where `i` is the index of the
    /// `meta` item in question. `meta` can also be an object for example `{key: value}` which can be
    /// accessed %{meta[key]}.
    public var meta: Data<Anything>? = nil

    /// Sets transition options used during Plotly.react updates.
    public struct Transition: Encodable {
        /// The duration of the transition, in milliseconds.
        /// 
        /// If equal to zero, updates are synchronous.
        public var duration: Double? = nil
    
        /// The easing function used for the transition
        public var easing: Easing? = nil
    
        /// Determines whether the figure's layout or traces smoothly transitions during updates that make
        /// both traces and layout change.
        public enum Ordering: String, Encodable {
            case layoutFirst = "layout first"
            case tracesFirst = "traces first"
        }
        /// Determines whether the figure's layout or traces smoothly transitions during updates that make
        /// both traces and layout change.
        public var ordering: Ordering? = nil
    
        /// Creates `Transition` object with specified properties.
        /// 
        /// - Parameters:
        ///   - duration: The duration of the transition, in milliseconds.
        ///   - easing: The easing function used for the transition
        ///   - ordering: Determines whether the figure's layout or traces smoothly transitions during updates
        ///   that make both traces and layout change.
        public init(duration: Double? = nil, easing: Easing? = nil, ordering: Ordering? = nil) {
            self.duration = duration
            self.easing = easing
            self.ordering = ordering
        }
        
    }
    /// Sets transition options used during Plotly.react updates.
    public var transition: Transition? = nil

    
    // MARK: - User Interaction

    /// Determines the mode of single click interactions.
    /// 
    /// *event* is the default value and emits the `plotly_click` event. In addition this mode emits the
    /// `plotly_selected` event in drag modes *lasso* and *select*, but with no event data attached
    /// (kept for compatibility reasons). The *select* flag enables selecting single data points via
    /// click. This mode also supports persistent selections, meaning that pressing Shift while
    /// clicking, adds to / subtracts from an existing selection. *select* with `hovermode`: *x* can be
    /// confusing, consider explicitly setting `hovermode`: *closest* when using this feature. Selection
    /// events are sent accordingly as long as *event* flag is set as well. When the *event* flag is
    /// missing, `plotly_click` and `plotly_selected` events are not fired.
    public struct ClickMode: OptionSet, Encodable {
        public let rawValue: Int
        public static var event: ClickMode { ClickMode(rawValue: 1 << 0) }
        public static var select: ClickMode { ClickMode(rawValue: 1 << 1) }
        public static var none: ClickMode { ClickMode(rawValue: 1 << 2) }
        
        public init(rawValue: Int) {
            self.rawValue = rawValue
        }
        
        public func encode(to encoder: Encoder) throws {
            var options = [String]()
            if (self.rawValue & 1 << 0) != 0 { options += ["event"] }
            if (self.rawValue & 1 << 1) != 0 { options += ["select"] }
            if (self.rawValue & 1 << 2) != 0 { options += ["none"] }
            var container = encoder.singleValueContainer()
            try container.encode(options.joined(separator: "+"))
        }
    }
    /// Determines the mode of single click interactions.
    /// 
    /// *event* is the default value and emits the `plotly_click` event. In addition this mode emits the
    /// `plotly_selected` event in drag modes *lasso* and *select*, but with no event data attached
    /// (kept for compatibility reasons). The *select* flag enables selecting single data points via
    /// click. This mode also supports persistent selections, meaning that pressing Shift while
    /// clicking, adds to / subtracts from an existing selection. *select* with `hovermode`: *x* can be
    /// confusing, consider explicitly setting `hovermode`: *closest* when using this feature. Selection
    /// events are sent accordingly as long as *event* flag is set as well. When the *event* flag is
    /// missing, `plotly_click` and `plotly_selected` events are not fired.
    public var clickMode: ClickMode? = nil

    /// Determines the mode of drag interactions.
    /// 
    /// *select* and *lasso* apply only to scatter traces with markers or text. *orbit* and *turntable*
    /// apply only to 3D scenes.
    public enum DragMode: Encodable {
        case zoom
        case pan
        case select
        case lasso
        case drawClosedPath
        case drawOpenPath
        case drawline
        case drawRect
        case drawCircle
        case orbit
        case turntable
        case off
        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .zoom:
                try container.encode("zoom")
            case .pan:
                try container.encode("pan")
            case .select:
                try container.encode("select")
            case .lasso:
                try container.encode("lasso")
            case .drawClosedPath:
                try container.encode("drawclosedpath")
            case .drawOpenPath:
                try container.encode("drawopenpath")
            case .drawline:
                try container.encode("drawline")
            case .drawRect:
                try container.encode("drawrect")
            case .drawCircle:
                try container.encode("drawcircle")
            case .orbit:
                try container.encode("orbit")
            case .turntable:
                try container.encode("turntable")
            case .off:
                try container.encode(false)
            }
        }
    }
    /// Determines the mode of drag interactions.
    /// 
    /// *select* and *lasso* apply only to scatter traces with markers or text. *orbit* and *turntable*
    /// apply only to 3D scenes.
    public var dragMode: DragMode? = nil

    /// Determines the mode of hover interactions.
    /// 
    /// If *closest*, a single hoverlabel will appear for the *closest* point within the
    /// `hoverdistance`. If *x* (or *y*), multiple hoverlabels will appear for multiple points at the
    /// *closest* x- (or y-) coordinate within the `hoverdistance`, with the caveat that no more than
    /// one hoverlabel will appear per trace. If *x unified* (or *y unified*), a single hoverlabel will
    /// appear multiple points at the closest x- (or y-) coordinate within the `hoverdistance` with the
    /// caveat that no more than one hoverlabel will appear per trace. In this mode, spikelines are
    /// enabled by default perpendicular to the specified axis. If false, hover interactions are
    /// disabled. If `clickmode` includes the *select* flag, `hovermode` defaults to *closest*. If
    /// `clickmode` lacks the *select* flag, it defaults to *x* or *y* (depending on the trace's
    /// `orientation` value) for plots based on cartesian coordinates. For anything else the default
    /// value is *closest*.
    public enum HoverMode: Encodable {
        case x
        case y
        case closest
        case off
        case xUnified
        case yUnified
        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
            case .x:
                try container.encode("x")
            case .y:
                try container.encode("y")
            case .closest:
                try container.encode("closest")
            case .off:
                try container.encode(false)
            case .xUnified:
                try container.encode("x unified")
            case .yUnified:
                try container.encode("y unified")
            }
        }
    }
    /// Determines the mode of hover interactions.
    /// 
    /// If *closest*, a single hoverlabel will appear for the *closest* point within the
    /// `hoverdistance`. If *x* (or *y*), multiple hoverlabels will appear for multiple points at the
    /// *closest* x- (or y-) coordinate within the `hoverdistance`, with the caveat that no more than
    /// one hoverlabel will appear per trace. If *x unified* (or *y unified*), a single hoverlabel will
    /// appear multiple points at the closest x- (or y-) coordinate within the `hoverdistance` with the
    /// caveat that no more than one hoverlabel will appear per trace. In this mode, spikelines are
    /// enabled by default perpendicular to the specified axis. If false, hover interactions are
    /// disabled. If `clickmode` includes the *select* flag, `hovermode` defaults to *closest*. If
    /// `clickmode` lacks the *select* flag, it defaults to *x* or *y* (depending on the trace's
    /// `orientation` value) for plots based on cartesian coordinates. For anything else the default
    /// value is *closest*.
    public var hoverMode: HoverMode? = nil

    /// Sets the default distance (in pixels) to look for data to add hover labels (-1 means no cutoff,
    /// 0 means no looking for data).
    /// 
    /// This is only a real distance for hovering on point-like objects, like scatter points. For
    /// area-like objects (bars, scatter fills, etc) hovering is on inside the area and off outside, but
    /// these objects will not supersede hover on point-like objects in case of conflict.
    public var hoverDistance: Int? = nil

    /// Sets the default distance (in pixels) to look for data to draw spikelines to (-1 means no
    /// cutoff, 0 means no looking for data).
    /// 
    /// As with hoverdistance, distance does not apply to area-like objects. In addition, some objects
    /// can be hovered on but will not generate spikelines, such as scatter fills.
    public var spikeDistance: Int? = nil

    public var hoverLabel: HoverLabel? = nil

    /// When `dragmode` is set to *select*, this limits the selection of the drag to horizontal,
    /// vertical or diagonal.
    /// 
    /// *h* only allows horizontal selection, *v* only vertical, *d* only diagonal and *any* sets no
    /// limit.
    public enum SelectDirection: String, Encodable {
        case h
        case v
        case d
        case any
    }
    /// When `dragmode` is set to *select*, this limits the selection of the drag to horizontal,
    /// vertical or diagonal.
    /// 
    /// *h* only allows horizontal selection, *v* only vertical, *d* only diagonal and *any* sets no
    /// limit.
    public var selectDirection: SelectDirection? = nil

    
    // MARK: - Subplots and Axes

    public struct Grid: Encodable {
        /// The number of rows in the grid.
        /// 
        /// If you provide a 2D `subplots` array or a `yaxes` array, its length is used as the default. But
        /// it's also possible to have a different length, if you want to leave a row at the end for
        /// non-cartesian subplots.
        public var rows: Int? = nil
    
        /// Is the first row the top or the bottom? Note that columns are always enumerated from left to
        /// right.
        public enum RowOrder: String, Encodable {
            case topToBottom = "top to bottom"
            case bottomToTop = "bottom to top"
        }
        /// Is the first row the top or the bottom? Note that columns are always enumerated from left to
        /// right.
        public var rowOrder: RowOrder? = nil
    
        /// The number of columns in the grid.
        /// 
        /// If you provide a 2D `subplots` array, the length of its longest row is used as the default. If
        /// you give an `xaxes` array, its length is used as the default. But it's also possible to have a
        /// different length, if you want to leave a row at the end for non-cartesian subplots.
        public var columns: Int? = nil
    
        /// Used for freeform grids, where some axes may be shared across subplots but others are not.
        /// 
        /// Each entry should be a cartesian subplot id, like *xy* or *x3y2*, or ** to leave that cell
        /// empty. You may reuse x axes within the same column, and y axes within the same row.
        /// Non-cartesian subplots and traces that support `domain` can place themselves in this grid
        /// separately using the `gridcell` attribute.
        public var subplots: InfoArray? = nil
    
        /// Used with `yaxes` when the x and y axes are shared across columns and rows.
        /// 
        /// Each entry should be an x axis id like *x*, *x2*, etc., or ** to not put an x axis in that
        /// column. Entries other than ** must be unique. Ignored if `subplots` is present. If missing but
        /// `yaxes` is present, will generate consecutive IDs.
        public var xAxes: InfoArray? = nil
    
        /// Used with `yaxes` when the x and y axes are shared across columns and rows.
        /// 
        /// Each entry should be an y axis id like *y*, *y2*, etc., or ** to not put a y axis in that row.
        /// Entries other than ** must be unique. Ignored if `subplots` is present. If missing but `xaxes`
        /// is present, will generate consecutive IDs.
        public var yAxes: InfoArray? = nil
    
        /// If no `subplots`, `xaxes`, or `yaxes` are given but we do have `rows` and `columns`, we can
        /// generate defaults using consecutive axis IDs, in two ways: *coupled* gives one x axis per column
        /// and one y axis per row.
        /// 
        /// *independent* uses a new xy pair for each cell, left-to-right across each row then iterating
        /// rows according to `roworder`.
        public enum Pattern: String, Encodable {
            case independent
            case coupled
        }
        /// If no `subplots`, `xaxes`, or `yaxes` are given but we do have `rows` and `columns`, we can
        /// generate defaults using consecutive axis IDs, in two ways: *coupled* gives one x axis per column
        /// and one y axis per row.
        /// 
        /// *independent* uses a new xy pair for each cell, left-to-right across each row then iterating
        /// rows according to `roworder`.
        public var pattern: Pattern? = nil
    
        /// Horizontal space between grid cells, expressed as a fraction of the total width available to one
        /// cell.
        /// 
        /// Defaults to 0.1 for coupled-axes grids and 0.2 for independent grids.
        public var xGap: Double? = nil
    
        /// Vertical space between grid cells, expressed as a fraction of the total height available to one
        /// cell.
        /// 
        /// Defaults to 0.1 for coupled-axes grids and 0.3 for independent grids.
        public var yGap: Double? = nil
    
        public struct Domain: Encodable {
            /// Sets the horizontal domain of this grid subplot (in plot fraction).
            /// 
            /// The first and last cells end exactly at the domain edges, with no grout around the edges.
            public var x: InfoArray? = nil
        
            /// Sets the vertical domain of this grid subplot (in plot fraction).
            /// 
            /// The first and last cells end exactly at the domain edges, with no grout around the edges.
            public var y: InfoArray? = nil
        
            /// Creates `Domain` object with specified properties.
            /// 
            /// - Parameters:
            ///   - x: Sets the horizontal domain of this grid subplot (in plot fraction).
            ///   - y: Sets the vertical domain of this grid subplot (in plot fraction).
            public init(x: InfoArray? = nil, y: InfoArray? = nil) {
                self.x = x
                self.y = y
            }
            
        }
        public var domain: Domain? = nil
    
        /// Sets where the x axis labels and titles go.
        /// 
        /// *bottom* means the very bottom of the grid. *bottom plot* is the lowest plot that each x axis is
        /// used in. *top* and *top plot* are similar.
        public enum XSide: String, Encodable {
            case bottom
            case bottomPlot = "bottom plot"
            case topPlot = "top plot"
            case top
        }
        /// Sets where the x axis labels and titles go.
        /// 
        /// *bottom* means the very bottom of the grid. *bottom plot* is the lowest plot that each x axis is
        /// used in. *top* and *top plot* are similar.
        public var xSide: XSide? = nil
    
        /// Sets where the y axis labels and titles go.
        /// 
        /// *left* means the very left edge of the grid. *left plot* is the leftmost plot that each y axis
        /// is used in. *right* and *right plot* are similar.
        public enum YSide: String, Encodable {
            case left
            case leftPlot = "left plot"
            case rightPlot = "right plot"
            case right
        }
        /// Sets where the y axis labels and titles go.
        /// 
        /// *left* means the very left edge of the grid. *left plot* is the leftmost plot that each y axis
        /// is used in. *right* and *right plot* are similar.
        public var ySide: YSide? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case rows
            case rowOrder = "roworder"
            case columns
            case subplots
            case xAxes = "xaxes"
            case yAxes = "yaxes"
            case pattern
            case xGap = "xgap"
            case yGap = "ygap"
            case domain
            case xSide = "xside"
            case ySide = "yside"
        }
        
        /// Creates `Grid` object with specified properties.
        /// 
        /// - Parameters:
        ///   - rows: The number of rows in the grid.
        ///   - rowOrder: Is the first row the top or the bottom? Note that columns are always enumerated from
        ///   left to right.
        ///   - columns: The number of columns in the grid.
        ///   - subplots: Used for freeform grids, where some axes may be shared across subplots but others
        ///   are not.
        ///   - xAxes: Used with `yaxes` when the x and y axes are shared across columns and rows.
        ///   - yAxes: Used with `yaxes` when the x and y axes are shared across columns and rows.
        ///   - pattern: If no `subplots`, `xaxes`, or `yaxes` are given but we do have `rows` and `columns`,
        ///   we can generate defaults using consecutive axis IDs, in two ways: *coupled* gives one x axis per
        ///   column and one y axis per row.
        ///   - xGap: Horizontal space between grid cells, expressed as a fraction of the total width
        ///   available to one cell.
        ///   - yGap: Vertical space between grid cells, expressed as a fraction of the total height available
        ///   to one cell.
        ///   - domain:
        ///   - xSide: Sets where the x axis labels and titles go.
        ///   - ySide: Sets where the y axis labels and titles go.
        public init(rows: Int? = nil, rowOrder: RowOrder? = nil, columns: Int? = nil, subplots:
                InfoArray? = nil, xAxes: InfoArray? = nil, yAxes: InfoArray? = nil, pattern: Pattern? = nil,
                xGap: Double? = nil, yGap: Double? = nil, domain: Domain? = nil, xSide: XSide? = nil, ySide:
                YSide? = nil) {
            self.rows = rows
            self.rowOrder = rowOrder
            self.columns = columns
            self.subplots = subplots
            self.xAxes = xAxes
            self.yAxes = yAxes
            self.pattern = pattern
            self.xGap = xGap
            self.yGap = yGap
            self.domain = domain
            self.xSide = xSide
            self.ySide = ySide
        }
        
    }
    public var grid: Grid? = nil

    /// Sets the default calendar system to use for interpreting and displaying dates throughout the
    /// plot.
    public var calendar: Calendar? = nil

    public var xAxis: [XAxis] = []

    public var yAxis: [YAxis] = []

    public var ternary: [Ternary] = []

    public var scene: [Scene] = []

    public var geo: [Geo] = []

    public var mapbox: [Mapbox] = []

    public var polar: [Polar] = []

    
    // MARK: - Legend, Labels and Shapes

    public struct Legend: Encodable {
        /// Sets the legend background color.
        /// 
        /// Defaults to `layout.paper_bgcolor`.
        public var backgroundColor: Color? = nil
    
        /// Sets the color of the border enclosing the legend.
        public var borderColor: Color? = nil
    
        /// Sets the width (in px) of the border enclosing the legend.
        public var borderWidth: Double? = nil
    
        /// Sets the font used to text the legend items.
        public var font: Font? = nil
    
        /// Sets the orientation of the legend.
        public var orientation: Orientation? = nil
    
        /// Determines the order at which the legend items are displayed.
        /// 
        /// If *normal*, the items are displayed top-to-bottom in the same order as the input data. If
        /// *reversed*, the items are displayed in the opposite order as *normal*. If *grouped*, the items
        /// are displayed in groups (when a trace `legendgroup` is provided). if *grouped+reversed*, the
        /// items are displayed in the opposite order as *grouped*.
        public struct TraceOrder: OptionSet, Encodable {
            public let rawValue: Int
            public static var reversed: TraceOrder { TraceOrder(rawValue: 1 << 0) }
            public static var grouped: TraceOrder { TraceOrder(rawValue: 1 << 1) }
            public static var normal: TraceOrder { TraceOrder(rawValue: 1 << 2) }
            
            public init(rawValue: Int) {
                self.rawValue = rawValue
            }
            
            public func encode(to encoder: Encoder) throws {
                var options = [String]()
                if (self.rawValue & 1 << 0) != 0 { options += ["reversed"] }
                if (self.rawValue & 1 << 1) != 0 { options += ["grouped"] }
                if (self.rawValue & 1 << 2) != 0 { options += ["normal"] }
                var container = encoder.singleValueContainer()
                try container.encode(options.joined(separator: "+"))
            }
        }
        /// Determines the order at which the legend items are displayed.
        /// 
        /// If *normal*, the items are displayed top-to-bottom in the same order as the input data. If
        /// *reversed*, the items are displayed in the opposite order as *normal*. If *grouped*, the items
        /// are displayed in groups (when a trace `legendgroup` is provided). if *grouped+reversed*, the
        /// items are displayed in the opposite order as *grouped*.
        public var traceOrder: TraceOrder? = nil
    
        /// Sets the amount of vertical space (in px) between legend groups.
        public var traceGroupGap: Double? = nil
    
        /// Determines if the legend items symbols scale with their corresponding *trace* attributes or
        /// remain *constant* independent of the symbol size on the graph.
        public enum ItemSizing: String, Encodable {
            case trace
            case constant
        }
        /// Determines if the legend items symbols scale with their corresponding *trace* attributes or
        /// remain *constant* independent of the symbol size on the graph.
        public var itemSizing: ItemSizing? = nil
    
        /// Sets the width (in px) of the legend item symbols (the part other than the title.text).
        public var itemWidth: Double? = nil
    
        /// Determines the behavior on legend item click.
        /// 
        /// *toggle* toggles the visibility of the item clicked on the graph. *toggleothers* makes the
        /// clicked item the sole visible item on the graph. *false* disable legend item click interactions.
        public enum ItemClick: Encodable {
            case toggle
            case toggleOthers
            case off
            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .toggle:
                    try container.encode("toggle")
                case .toggleOthers:
                    try container.encode("toggleothers")
                case .off:
                    try container.encode(false)
                }
            }
        }
        /// Determines the behavior on legend item click.
        /// 
        /// *toggle* toggles the visibility of the item clicked on the graph. *toggleothers* makes the
        /// clicked item the sole visible item on the graph. *false* disable legend item click interactions.
        public var itemClick: ItemClick? = nil
    
        /// Determines the behavior on legend item double-click.
        /// 
        /// *toggle* toggles the visibility of the item clicked on the graph. *toggleothers* makes the
        /// clicked item the sole visible item on the graph. *false* disable legend item double-click
        /// interactions.
        public enum ItemDoubleClick: Encodable {
            case toggle
            case toggleOthers
            case off
            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .toggle:
                    try container.encode("toggle")
                case .toggleOthers:
                    try container.encode("toggleothers")
                case .off:
                    try container.encode(false)
                }
            }
        }
        /// Determines the behavior on legend item double-click.
        /// 
        /// *toggle* toggles the visibility of the item clicked on the graph. *toggleothers* makes the
        /// clicked item the sole visible item on the graph. *false* disable legend item double-click
        /// interactions.
        public var itemDoubleClick: ItemDoubleClick? = nil
    
        /// Sets the x position (in normalized coordinates) of the legend.
        /// 
        /// Defaults to *1.02* for vertical legends and defaults to *0* for horizontal legends.
        public var x: Double? = nil
    
        /// Sets the legend's horizontal position anchor.
        /// 
        /// This anchor binds the `x` position to the *left*, *center* or *right* of the legend. Value
        /// *auto* anchors legends to the right for `x` values greater than or equal to 2/3, anchors legends
        /// to the left for `x` values less than or equal to 1/3 and anchors legends with respect to their
        /// center otherwise.
        public var xAnchor: XAutoAnchor? = nil
    
        /// Sets the y position (in normalized coordinates) of the legend.
        /// 
        /// Defaults to *1* for vertical legends, defaults to *-0.1* for horizontal legends on graphs w/o
        /// range sliders and defaults to *1.1* for horizontal legends on graph with one or multiple range
        /// sliders.
        public var y: Double? = nil
    
        /// Sets the legend's vertical position anchor This anchor binds the `y` position to the *top*,
        /// *middle* or *bottom* of the legend.
        /// 
        /// Value *auto* anchors legends at their bottom for `y` values less than or equal to 1/3, anchors
        /// legends to at their top for `y` values greater than or equal to 2/3 and anchors legends with
        /// respect to their middle otherwise.
        public var yAnchor: YAutoAnchor? = nil
    
        /// Controls persistence of legend-driven changes in trace and pie label visibility.
        /// 
        /// Defaults to `layout.uirevision`.
        public var uiRevision: Anything? = nil
    
        /// Sets the vertical alignment of the symbols with respect to their associated text.
        public var verticalAlign: VerticalAlign? = nil
    
        public var title: LegendTitle? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case backgroundColor = "bgcolor"
            case borderColor = "bordercolor"
            case borderWidth = "borderwidth"
            case font
            case orientation
            case traceOrder = "traceorder"
            case traceGroupGap = "tracegroupgap"
            case itemSizing = "itemsizing"
            case itemWidth = "itemwidth"
            case itemClick = "itemclick"
            case itemDoubleClick = "itemdoubleclick"
            case x
            case xAnchor = "xanchor"
            case y
            case yAnchor = "yanchor"
            case uiRevision = "uirevision"
            case verticalAlign = "valign"
            case title
        }
        
        /// Creates `Legend` object with specified properties.
        /// 
        /// - Parameters:
        ///   - backgroundColor: Sets the legend background color.
        ///   - borderColor: Sets the color of the border enclosing the legend.
        ///   - borderWidth: Sets the width (in px) of the border enclosing the legend.
        ///   - font: Sets the font used to text the legend items.
        ///   - orientation: Sets the orientation of the legend.
        ///   - traceOrder: Determines the order at which the legend items are displayed.
        ///   - traceGroupGap: Sets the amount of vertical space (in px) between legend groups.
        ///   - itemSizing: Determines if the legend items symbols scale with their corresponding *trace*
        ///   attributes or remain *constant* independent of the symbol size on the graph.
        ///   - itemWidth: Sets the width (in px) of the legend item symbols (the part other than the
        ///   title.text).
        ///   - itemClick: Determines the behavior on legend item click.
        ///   - itemDoubleClick: Determines the behavior on legend item double-click.
        ///   - x: Sets the x position (in normalized coordinates) of the legend.
        ///   - xAnchor: Sets the legend's horizontal position anchor.
        ///   - y: Sets the y position (in normalized coordinates) of the legend.
        ///   - yAnchor: Sets the legend's vertical position anchor This anchor binds the `y` position to the
        ///   *top*, *middle* or *bottom* of the legend.
        ///   - uiRevision: Controls persistence of legend-driven changes in trace and pie label visibility.
        ///   - verticalAlign: Sets the vertical alignment of the symbols with respect to their associated
        ///   text.
        ///   - title:
        public init(backgroundColor: Color? = nil, borderColor: Color? = nil, borderWidth: Double? =
                nil, font: Font? = nil, orientation: Orientation? = nil, traceOrder: TraceOrder? = nil,
                traceGroupGap: Double? = nil, itemSizing: ItemSizing? = nil, itemWidth: Double? = nil,
                itemClick: ItemClick? = nil, itemDoubleClick: ItemDoubleClick? = nil, x: Double? = nil, xAnchor:
                XAutoAnchor? = nil, y: Double? = nil, yAnchor: YAutoAnchor? = nil, uiRevision: Anything? = nil,
                verticalAlign: VerticalAlign? = nil, title: LegendTitle? = nil) {
            self.backgroundColor = backgroundColor
            self.borderColor = borderColor
            self.borderWidth = borderWidth
            self.font = font
            self.orientation = orientation
            self.traceOrder = traceOrder
            self.traceGroupGap = traceGroupGap
            self.itemSizing = itemSizing
            self.itemWidth = itemWidth
            self.itemClick = itemClick
            self.itemDoubleClick = itemDoubleClick
            self.x = x
            self.xAnchor = xAnchor
            self.y = y
            self.yAnchor = yAnchor
            self.uiRevision = uiRevision
            self.verticalAlign = verticalAlign
            self.title = title
        }
        
    }
    public var legend: Legend? = nil

    public struct Annotation: Encodable {
        /// Determines whether or not this annotation is visible.
        public var visible: Bool? = nil
    
        /// Sets the text associated with this annotation.
        /// 
        /// Plotly uses a subset of HTML tags to do things like newline (<br>), bold (<b></b>), italics
        /// (<i></i>), hyperlinks (<a href='...'></a>). Tags <em>, <sup>, <sub> <span> are also supported.
        public var text: String? = nil
    
        /// Sets the angle at which the `text` is drawn with respect to the horizontal.
        public var textAngle: Angle? = nil
    
        /// Sets the annotation text font.
        public var font: Font? = nil
    
        /// Sets an explicit width for the text box.
        /// 
        /// null (default) lets the text set the box width. Wider text will be clipped. There is no
        /// automatic wrapping; use <br> to start a new line.
        public var width: Double? = nil
    
        /// Sets an explicit height for the text box.
        /// 
        /// null (default) lets the text set the box height. Taller text will be clipped.
        public var height: Double? = nil
    
        /// Sets the opacity of the annotation (text + arrow).
        public var opacity: Double? = nil
    
        /// Sets the horizontal alignment of the `text` within the box.
        /// 
        /// Has an effect only if `text` spans two or more lines (i.e. `text` contains one or more <br> HTML
        /// tags) or if an explicit width is set to override the text width.
        public var align: HorizontalAlign? = nil
    
        /// Sets the vertical alignment of the `text` within the box.
        /// 
        /// Has an effect only if an explicit height is set to override the text height.
        public var verticalAlign: VerticalAlign? = nil
    
        /// Sets the background color of the annotation.
        public var backgroundColor: Color? = nil
    
        /// Sets the color of the border enclosing the annotation `text`.
        public var borderColor: Color? = nil
    
        /// Sets the padding (in px) between the `text` and the enclosing border.
        public var borderPadding: Double? = nil
    
        /// Sets the width (in px) of the border enclosing the annotation `text`.
        public var borderWidth: Double? = nil
    
        /// Determines whether or not the annotation is drawn with an arrow.
        /// 
        /// If *true*, `text` is placed near the arrow's tail. If *false*, `text` lines up with the `x` and
        /// `y` provided.
        public var showArrow: Bool? = nil
    
        /// Sets the color of the annotation arrow.
        public var arrowColor: Color? = nil
    
        /// Sets the end annotation arrow head style.
        public var arrowHead: Int? = nil
    
        /// Sets the start annotation arrow head style.
        public var startArrowHead: Int? = nil
    
        /// Sets the annotation arrow head position.
        public struct ArrowSide: OptionSet, Encodable {
            public let rawValue: Int
            public static var end: ArrowSide { ArrowSide(rawValue: 1 << 0) }
            public static var start: ArrowSide { ArrowSide(rawValue: 1 << 1) }
            public static var none: ArrowSide { ArrowSide(rawValue: 1 << 2) }
            
            public init(rawValue: Int) {
                self.rawValue = rawValue
            }
            
            public func encode(to encoder: Encoder) throws {
                var options = [String]()
                if (self.rawValue & 1 << 0) != 0 { options += ["end"] }
                if (self.rawValue & 1 << 1) != 0 { options += ["start"] }
                if (self.rawValue & 1 << 2) != 0 { options += ["none"] }
                var container = encoder.singleValueContainer()
                try container.encode(options.joined(separator: "+"))
            }
        }
        /// Sets the annotation arrow head position.
        public var arrowSide: ArrowSide? = nil
    
        /// Sets the size of the end annotation arrow head, relative to `arrowwidth`.
        /// 
        /// A value of 1 (default) gives a head about 3x as wide as the line.
        public var arrowSize: Double? = nil
    
        /// Sets the size of the start annotation arrow head, relative to `arrowwidth`.
        /// 
        /// A value of 1 (default) gives a head about 3x as wide as the line.
        public var startArrowSize: Double? = nil
    
        /// Sets the width (in px) of annotation arrow line.
        public var arrowWidth: Double? = nil
    
        /// Sets a distance, in pixels, to move the end arrowhead away from the position it is pointing at,
        /// for example to point at the edge of a marker independent of zoom.
        /// 
        /// Note that this shortens the arrow from the `ax` / `ay` vector, in contrast to `xshift` /
        /// `yshift` which moves everything by this amount.
        public var standoff: Double? = nil
    
        /// Sets a distance, in pixels, to move the start arrowhead away from the position it is pointing
        /// at, for example to point at the edge of a marker independent of zoom.
        /// 
        /// Note that this shortens the arrow from the `ax` / `ay` vector, in contrast to `xshift` /
        /// `yshift` which moves everything by this amount.
        public var startStandoff: Double? = nil
    
        /// Sets the x component of the arrow tail about the arrow head.
        /// 
        /// If `axref` is `pixel`, a positive (negative) component corresponds to an arrow pointing from
        /// right to left (left to right). If `axref` is not `pixel` and is exactly the same as `xref`, this
        /// is an absolute value on that axis, like `x`, specified in the same coordinates as `xref`.
        public var ax: Anything? = nil
    
        /// Sets the y component of the arrow tail about the arrow head.
        /// 
        /// If `ayref` is `pixel`, a positive (negative) component corresponds to an arrow pointing from
        /// bottom to top (top to bottom). If `ayref` is not `pixel` and is exactly the same as `yref`, this
        /// is an absolute value on that axis, like `y`, specified in the same coordinates as `yref`.
        public var ay: Anything? = nil
    
        /// Indicates in what coordinates the tail of the annotation (ax,ay) is specified.
        /// 
        /// If set to a ax axis id (e.g. *ax* or *ax2*), the `ax` position refers to a ax coordinate. If set
        /// to *paper*, the `ax` position refers to the distance from the left of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the left (right). If set to a ax axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the left of the domain of that axis:
        /// e.g., *ax2 domain* refers to the domain of the second ax axis and a ax position of 0.5 refers to
        /// the point between the left and the right of the domain of the second ax axis. In order for
        /// absolute positioning of the arrow to work, *axref* must be exactly the same as *xref*, otherwise
        /// *axref* will revert to *pixel* (explained next). For relative positioning, *axref* can be set to
        /// *pixel*, in which case the *ax* value is specified in pixels relative to *x*. Absolute
        /// positioning is useful for trendline annotations which should continue to indicate the correct
        /// trend when zoomed. Relative positioning is useful for specifying the text offset for an
        /// annotated point.
        public enum AxReference: Encodable {
            case pixel
            case xAxis(XAxis)
            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .pixel:
                    try container.encode("pixel")
                case .xAxis(let axis):
                    try container.encode("x\(axis.uid)")
                }
            }
        }
        /// Indicates in what coordinates the tail of the annotation (ax,ay) is specified.
        /// 
        /// If set to a ax axis id (e.g. *ax* or *ax2*), the `ax` position refers to a ax coordinate. If set
        /// to *paper*, the `ax` position refers to the distance from the left of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the left (right). If set to a ax axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the left of the domain of that axis:
        /// e.g., *ax2 domain* refers to the domain of the second ax axis and a ax position of 0.5 refers to
        /// the point between the left and the right of the domain of the second ax axis. In order for
        /// absolute positioning of the arrow to work, *axref* must be exactly the same as *xref*, otherwise
        /// *axref* will revert to *pixel* (explained next). For relative positioning, *axref* can be set to
        /// *pixel*, in which case the *ax* value is specified in pixels relative to *x*. Absolute
        /// positioning is useful for trendline annotations which should continue to indicate the correct
        /// trend when zoomed. Relative positioning is useful for specifying the text offset for an
        /// annotated point.
        public var axReference: AxReference? = nil
    
        /// Indicates in what coordinates the tail of the annotation (ax,ay) is specified.
        /// 
        /// If set to a ay axis id (e.g. *ay* or *ay2*), the `ay` position refers to a ay coordinate. If set
        /// to *paper*, the `ay` position refers to the distance from the bottom of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set to a ay axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the bottom of the domain of that axis:
        /// e.g., *ay2 domain* refers to the domain of the second ay axis and a ay position of 0.5 refers to
        /// the point between the bottom and the top of the domain of the second ay axis. In order for
        /// absolute positioning of the arrow to work, *ayref* must be exactly the same as *yref*, otherwise
        /// *ayref* will revert to *pixel* (explained next). For relative positioning, *ayref* can be set to
        /// *pixel*, in which case the *ay* value is specified in pixels relative to *y*. Absolute
        /// positioning is useful for trendline annotations which should continue to indicate the correct
        /// trend when zoomed. Relative positioning is useful for specifying the text offset for an
        /// annotated point.
        public enum AyReference: Encodable {
            case pixel
            case yAxis(YAxis)
            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .pixel:
                    try container.encode("pixel")
                case .yAxis(let axis):
                    try container.encode("y\(axis.uid)")
                }
            }
        }
        /// Indicates in what coordinates the tail of the annotation (ax,ay) is specified.
        /// 
        /// If set to a ay axis id (e.g. *ay* or *ay2*), the `ay` position refers to a ay coordinate. If set
        /// to *paper*, the `ay` position refers to the distance from the bottom of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set to a ay axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the bottom of the domain of that axis:
        /// e.g., *ay2 domain* refers to the domain of the second ay axis and a ay position of 0.5 refers to
        /// the point between the bottom and the top of the domain of the second ay axis. In order for
        /// absolute positioning of the arrow to work, *ayref* must be exactly the same as *yref*, otherwise
        /// *ayref* will revert to *pixel* (explained next). For relative positioning, *ayref* can be set to
        /// *pixel*, in which case the *ay* value is specified in pixels relative to *y*. Absolute
        /// positioning is useful for trendline annotations which should continue to indicate the correct
        /// trend when zoomed. Relative positioning is useful for specifying the text offset for an
        /// annotated point.
        public var ayReference: AyReference? = nil
    
        /// Sets the annotation's x coordinate axis.
        /// 
        /// If set to a x axis id (e.g. *x* or *x2*), the `x` position refers to a x coordinate. If set to
        /// *paper*, the `x` position refers to the distance from the left of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the left (right). If set to a x axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the left of the domain of that axis:
        /// e.g., *x2 domain* refers to the domain of the second x axis and a x position of 0.5 refers to
        /// the point between the left and the right of the domain of the second x axis.
        public var xReference: XAxisReference? = nil
    
        /// Sets the annotation's x position.
        /// 
        /// If the axis `type` is *log*, then you must take the log of your desired range. If the axis
        /// `type` is *date*, it should be date strings, like date data, though Date objects and unix
        /// milliseconds will be accepted and converted to strings. If the axis `type` is *category*, it
        /// should be numbers, using the scale where each category is assigned a serial number from zero in
        /// the order it appears.
        public var x: Anything? = nil
    
        /// Sets the text box's horizontal position anchor This anchor binds the `x` position to the *left*,
        /// *center* or *right* of the annotation.
        /// 
        /// For example, if `x` is set to 1, `xref` to *paper* and `xanchor` to *right* then the right-most
        /// portion of the annotation lines up with the right-most edge of the plotting area. If *auto*, the
        /// anchor is equivalent to *center* for data-referenced annotations or if there is an arrow,
        /// whereas for paper-referenced with no arrow, the anchor picked corresponds to the closest side.
        public var xAnchor: XAutoAnchor? = nil
    
        /// Shifts the position of the whole annotation and arrow to the right (positive) or left (negative)
        /// by this many pixels.
        public var xShift: Double? = nil
    
        /// Sets the annotation's y coordinate axis.
        /// 
        /// If set to a y axis id (e.g. *y* or *y2*), the `y` position refers to a y coordinate. If set to
        /// *paper*, the `y` position refers to the distance from the bottom of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set to a y axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the bottom of the domain of that axis:
        /// e.g., *y2 domain* refers to the domain of the second y axis and a y position of 0.5 refers to
        /// the point between the bottom and the top of the domain of the second y axis.
        public var yReference: YAxisReference? = nil
    
        /// Sets the annotation's y position.
        /// 
        /// If the axis `type` is *log*, then you must take the log of your desired range. If the axis
        /// `type` is *date*, it should be date strings, like date data, though Date objects and unix
        /// milliseconds will be accepted and converted to strings. If the axis `type` is *category*, it
        /// should be numbers, using the scale where each category is assigned a serial number from zero in
        /// the order it appears.
        public var y: Anything? = nil
    
        /// Sets the text box's vertical position anchor This anchor binds the `y` position to the *top*,
        /// *middle* or *bottom* of the annotation.
        /// 
        /// For example, if `y` is set to 1, `yref` to *paper* and `yanchor` to *top* then the top-most
        /// portion of the annotation lines up with the top-most edge of the plotting area. If *auto*, the
        /// anchor is equivalent to *middle* for data-referenced annotations or if there is an arrow,
        /// whereas for paper-referenced with no arrow, the anchor picked corresponds to the closest side.
        public var yAnchor: YAutoAnchor? = nil
    
        /// Shifts the position of the whole annotation and arrow up (positive) or down (negative) by this
        /// many pixels.
        public var yShift: Double? = nil
    
        /// Makes this annotation respond to clicks on the plot.
        /// 
        /// If you click a data point that exactly matches the `x` and `y` values of this annotation, and it
        /// is hidden (visible: false), it will appear. In *onoff* mode, you must click the same point again
        /// to make it disappear, so if you click multiple points, you can show multiple annotations. In
        /// *onout* mode, a click anywhere else in the plot (on another data point or not) will hide this
        /// annotation. If you need to show/hide this annotation in response to different `x` or `y` values,
        /// you can set `xclick` and/or `yclick`. This is useful for example to label the side of a bar. To
        /// label markers though, `standoff` is preferred over `xclick` and `yclick`.
        public enum ClickToShow: Encodable {
            case off
            case onOff
            case onOut
            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                switch self {
                case .off:
                    try container.encode(false)
                case .onOff:
                    try container.encode("onoff")
                case .onOut:
                    try container.encode("onout")
                }
            }
        }
        /// Makes this annotation respond to clicks on the plot.
        /// 
        /// If you click a data point that exactly matches the `x` and `y` values of this annotation, and it
        /// is hidden (visible: false), it will appear. In *onoff* mode, you must click the same point again
        /// to make it disappear, so if you click multiple points, you can show multiple annotations. In
        /// *onout* mode, a click anywhere else in the plot (on another data point or not) will hide this
        /// annotation. If you need to show/hide this annotation in response to different `x` or `y` values,
        /// you can set `xclick` and/or `yclick`. This is useful for example to label the side of a bar. To
        /// label markers though, `standoff` is preferred over `xclick` and `yclick`.
        public var clickToShow: ClickToShow? = nil
    
        /// Toggle this annotation when clicking a data point whose `x` value is `xclick` rather than the
        /// annotation's `x` value.
        public var xClick: Anything? = nil
    
        /// Toggle this annotation when clicking a data point whose `y` value is `yclick` rather than the
        /// annotation's `y` value.
        public var yClick: Anything? = nil
    
        /// Sets text to appear when hovering over this annotation.
        /// 
        /// If omitted or blank, no hover label will appear.
        public var hoverText: String? = nil
    
        public struct HoverLabel: Encodable {
            /// Sets the background color of the hover label.
            /// 
            /// By default uses the annotation's `bgcolor` made opaque, or white if it was transparent.
            public var backgroundColor: Color? = nil
        
            /// Sets the border color of the hover label.
            /// 
            /// By default uses either dark grey or white, for maximum contrast with `hoverlabel.bgcolor`.
            public var borderColor: Color? = nil
        
            /// Sets the hover label text font.
            /// 
            /// By default uses the global hover font and size, with color from `hoverlabel.bordercolor`.
            public var font: Font? = nil
        
            /// Decoding and encoding keys compatible with Plotly schema.
            enum CodingKeys: String, CodingKey {
                case backgroundColor = "bgcolor"
                case borderColor = "bordercolor"
                case font
            }
            
            /// Creates `HoverLabel` object with specified properties.
            /// 
            /// - Parameters:
            ///   - backgroundColor: Sets the background color of the hover label.
            ///   - borderColor: Sets the border color of the hover label.
            ///   - font: Sets the hover label text font.
            public init(backgroundColor: Color? = nil, borderColor: Color? = nil, font: Font? = nil) {
                self.backgroundColor = backgroundColor
                self.borderColor = borderColor
                self.font = font
            }
            
        }
        public var hoverLabel: HoverLabel? = nil
    
        /// Determines whether the annotation text box captures mouse move and click events, or allows those
        /// events to pass through to data points in the plot that may be behind the annotation.
        /// 
        /// By default `captureevents` is *false* unless `hovertext` is provided. If you use the event
        /// `plotly_clickannotation` without `hovertext` you must explicitly enable `captureevents`.
        public var captureEvents: Bool? = nil
    
        /// When used in a template, named items are created in the output figure in addition to any items
        /// the figure already has in this array.
        /// 
        /// You can modify these items in the output figure by making your own item with `templateitemname`
        /// matching this `name` alongside your modifications (including `visible: false` or `enabled:
        /// false` to hide it). Has no effect outside of a template.
        public var name: String? = nil
    
        /// Used to refer to a named item in this array in the template.
        /// 
        /// Named items from the template will be created even without a matching item in the input figure,
        /// but you can modify one by making an item with `templateitemname` matching its `name`, alongside
        /// your modifications (including `visible: false` or `enabled: false` to hide it). If there is no
        /// template or no matching item, this item will be hidden unless you explicitly show it with
        /// `visible: true`.
        public var templateItemName: String? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case visible
            case text
            case textAngle = "textangle"
            case font
            case width
            case height
            case opacity
            case align
            case verticalAlign = "valign"
            case backgroundColor = "bgcolor"
            case borderColor = "bordercolor"
            case borderPadding = "borderpad"
            case borderWidth = "borderwidth"
            case showArrow = "showarrow"
            case arrowColor = "arrowcolor"
            case arrowHead = "arrowhead"
            case startArrowHead = "startarrowhead"
            case arrowSide = "arrowside"
            case arrowSize = "arrowsize"
            case startArrowSize = "startarrowsize"
            case arrowWidth = "arrowwidth"
            case standoff
            case startStandoff = "startstandoff"
            case ax
            case ay
            case axReference = "axref"
            case ayReference = "ayref"
            case xReference = "xref"
            case x
            case xAnchor = "xanchor"
            case xShift = "xshift"
            case yReference = "yref"
            case y
            case yAnchor = "yanchor"
            case yShift = "yshift"
            case clickToShow = "clicktoshow"
            case xClick = "xclick"
            case yClick = "yclick"
            case hoverText = "hovertext"
            case hoverLabel = "hoverlabel"
            case captureEvents = "captureevents"
            case name
            case templateItemName = "templateitemname"
        }
        
        /// Creates `Annotation` object with specified properties.
        /// 
        /// - Parameters:
        ///   - visible: Determines whether or not this annotation is visible.
        ///   - text: Sets the text associated with this annotation.
        ///   - textAngle: Sets the angle at which the `text` is drawn with respect to the horizontal.
        ///   - font: Sets the annotation text font.
        ///   - width: Sets an explicit width for the text box.
        ///   - height: Sets an explicit height for the text box.
        ///   - opacity: Sets the opacity of the annotation (text + arrow).
        ///   - align: Sets the horizontal alignment of the `text` within the box.
        ///   - verticalAlign: Sets the vertical alignment of the `text` within the box.
        ///   - backgroundColor: Sets the background color of the annotation.
        ///   - borderColor: Sets the color of the border enclosing the annotation `text`.
        ///   - borderPadding: Sets the padding (in px) between the `text` and the enclosing border.
        ///   - borderWidth: Sets the width (in px) of the border enclosing the annotation `text`.
        ///   - showArrow: Determines whether or not the annotation is drawn with an arrow.
        ///   - arrowColor: Sets the color of the annotation arrow.
        ///   - arrowHead: Sets the end annotation arrow head style.
        ///   - startArrowHead: Sets the start annotation arrow head style.
        ///   - arrowSide: Sets the annotation arrow head position.
        ///   - arrowSize: Sets the size of the end annotation arrow head, relative to `arrowwidth`.
        ///   - startArrowSize: Sets the size of the start annotation arrow head, relative to `arrowwidth`.
        ///   - arrowWidth: Sets the width (in px) of annotation arrow line.
        ///   - standoff: Sets a distance, in pixels, to move the end arrowhead away from the position it is
        ///   pointing at, for example to point at the edge of a marker independent of zoom.
        ///   - startStandoff: Sets a distance, in pixels, to move the start arrowhead away from the position
        ///   it is pointing at, for example to point at the edge of a marker independent of zoom.
        ///   - ax: Sets the x component of the arrow tail about the arrow head.
        ///   - ay: Sets the y component of the arrow tail about the arrow head.
        ///   - axReference: Indicates in what coordinates the tail of the annotation (ax,ay) is specified.
        ///   - ayReference: Indicates in what coordinates the tail of the annotation (ax,ay) is specified.
        ///   - xReference: Sets the annotation's x coordinate axis.
        ///   - x: Sets the annotation's x position.
        ///   - xAnchor: Sets the text box's horizontal position anchor This anchor binds the `x` position to
        ///   the *left*, *center* or *right* of the annotation.
        ///   - xShift: Shifts the position of the whole annotation and arrow to the right (positive) or left
        ///   (negative) by this many pixels.
        ///   - yReference: Sets the annotation's y coordinate axis.
        ///   - y: Sets the annotation's y position.
        ///   - yAnchor: Sets the text box's vertical position anchor This anchor binds the `y` position to
        ///   the *top*, *middle* or *bottom* of the annotation.
        ///   - yShift: Shifts the position of the whole annotation and arrow up (positive) or down (negative)
        ///   by this many pixels.
        ///   - clickToShow: Makes this annotation respond to clicks on the plot.
        ///   - xClick: Toggle this annotation when clicking a data point whose `x` value is `xclick` rather
        ///   than the annotation's `x` value.
        ///   - yClick: Toggle this annotation when clicking a data point whose `y` value is `yclick` rather
        ///   than the annotation's `y` value.
        ///   - hoverText: Sets text to appear when hovering over this annotation.
        ///   - hoverLabel:
        ///   - captureEvents: Determines whether the annotation text box captures mouse move and click
        ///   events, or allows those events to pass through to data points in the plot that may be behind the
        ///   annotation.
        ///   - name: When used in a template, named items are created in the output figure in addition to any
        ///   items the figure already has in this array.
        ///   - templateItemName: Used to refer to a named item in this array in the template.
        public init(visible: Bool? = nil, text: String? = nil, textAngle: Angle? = nil, font: Font? =
                nil, width: Double? = nil, height: Double? = nil, opacity: Double? = nil, align:
                HorizontalAlign? = nil, verticalAlign: VerticalAlign? = nil, backgroundColor: Color? = nil,
                borderColor: Color? = nil, borderPadding: Double? = nil, borderWidth: Double? = nil, showArrow:
                Bool? = nil, arrowColor: Color? = nil, arrowHead: Int? = nil, startArrowHead: Int? = nil,
                arrowSide: ArrowSide? = nil, arrowSize: Double? = nil, startArrowSize: Double? = nil,
                arrowWidth: Double? = nil, standoff: Double? = nil, startStandoff: Double? = nil, ax: Anything?
                = nil, ay: Anything? = nil, axReference: AxReference? = nil, ayReference: AyReference? = nil,
                xReference: XAxisReference? = nil, x: Anything? = nil, xAnchor: XAutoAnchor? = nil, xShift:
                Double? = nil, yReference: YAxisReference? = nil, y: Anything? = nil, yAnchor: YAutoAnchor? =
                nil, yShift: Double? = nil, clickToShow: ClickToShow? = nil, xClick: Anything? = nil, yClick:
                Anything? = nil, hoverText: String? = nil, hoverLabel: HoverLabel? = nil, captureEvents: Bool? =
                nil, name: String? = nil, templateItemName: String? = nil) {
            self.visible = visible
            self.text = text
            self.textAngle = textAngle
            self.font = font
            self.width = width
            self.height = height
            self.opacity = opacity
            self.align = align
            self.verticalAlign = verticalAlign
            self.backgroundColor = backgroundColor
            self.borderColor = borderColor
            self.borderPadding = borderPadding
            self.borderWidth = borderWidth
            self.showArrow = showArrow
            self.arrowColor = arrowColor
            self.arrowHead = arrowHead
            self.startArrowHead = startArrowHead
            self.arrowSide = arrowSide
            self.arrowSize = arrowSize
            self.startArrowSize = startArrowSize
            self.arrowWidth = arrowWidth
            self.standoff = standoff
            self.startStandoff = startStandoff
            self.ax = ax
            self.ay = ay
            self.axReference = axReference
            self.ayReference = ayReference
            self.xReference = xReference
            self.x = x
            self.xAnchor = xAnchor
            self.xShift = xShift
            self.yReference = yReference
            self.y = y
            self.yAnchor = yAnchor
            self.yShift = yShift
            self.clickToShow = clickToShow
            self.xClick = xClick
            self.yClick = yClick
            self.hoverText = hoverText
            self.hoverLabel = hoverLabel
            self.captureEvents = captureEvents
            self.name = name
            self.templateItemName = templateItemName
        }
        
    }
    public var annotations: [Annotation]? = nil

    public struct Shape: Encodable {
        /// Determines whether or not this shape is visible.
        public var visible: Bool? = nil
    
        /// Specifies the shape type to be drawn.
        /// 
        /// If *line*, a line is drawn from (`x0`,`y0`) to (`x1`,`y1`) with respect to the axes' sizing
        /// mode. If *circle*, a circle is drawn from ((`x0`+`x1`)/2, (`y0`+`y1`)/2)) with radius
        /// (|(`x0`+`x1`)/2 - `x0`|, |(`y0`+`y1`)/2 -`y0`)|) with respect to the axes' sizing mode. If
        /// *rect*, a rectangle is drawn linking (`x0`,`y0`), (`x1`,`y0`), (`x1`,`y1`), (`x0`,`y1`),
        /// (`x0`,`y0`) with respect to the axes' sizing mode. If *path*, draw a custom SVG path using
        /// `path`. with respect to the axes' sizing mode.
        public enum `Type`: String, Encodable {
            case circle
            case rect
            case path
            case line
        }
        /// Specifies the shape type to be drawn.
        /// 
        /// If *line*, a line is drawn from (`x0`,`y0`) to (`x1`,`y1`) with respect to the axes' sizing
        /// mode. If *circle*, a circle is drawn from ((`x0`+`x1`)/2, (`y0`+`y1`)/2)) with radius
        /// (|(`x0`+`x1`)/2 - `x0`|, |(`y0`+`y1`)/2 -`y0`)|) with respect to the axes' sizing mode. If
        /// *rect*, a rectangle is drawn linking (`x0`,`y0`), (`x1`,`y0`), (`x1`,`y1`), (`x0`,`y1`),
        /// (`x0`,`y0`) with respect to the axes' sizing mode. If *path*, draw a custom SVG path using
        /// `path`. with respect to the axes' sizing mode.
        public var type: `Type`? = nil
    
        /// Specifies whether shapes are drawn below or above traces.
        public var layer: ShapeLayer? = nil
    
        /// Sets the shape's x coordinate axis.
        /// 
        /// If set to a x axis id (e.g. *x* or *x2*), the `x` position refers to a x coordinate. If set to
        /// *paper*, the `x` position refers to the distance from the left of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the left (right). If set to a x axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the left of the domain of that axis:
        /// e.g., *x2 domain* refers to the domain of the second x axis and a x position of 0.5 refers to
        /// the point between the left and the right of the domain of the second x axis. If the axis `type`
        /// is *log*, then you must take the log of your desired range. If the axis `type` is *date*, then
        /// you must convert the date to unix time in milliseconds.
        public var xReference: XAxisReference? = nil
    
        /// Sets the shapes's sizing mode along the x axis.
        /// 
        /// If set to *scaled*, `x0`, `x1` and x coordinates within `path` refer to data values on the x
        /// axis or a fraction of the plot area's width (`xref` set to *paper*). If set to *pixel*,
        /// `xanchor` specifies the x position in terms of data or plot fraction but `x0`, `x1` and x
        /// coordinates within `path` are pixels relative to `xanchor`. This way, the shape can have a fixed
        /// width while maintaining a position relative to data or plot fraction.
        public enum XSizeMode: String, Encodable {
            case scaled
            case pixel
        }
        /// Sets the shapes's sizing mode along the x axis.
        /// 
        /// If set to *scaled*, `x0`, `x1` and x coordinates within `path` refer to data values on the x
        /// axis or a fraction of the plot area's width (`xref` set to *paper*). If set to *pixel*,
        /// `xanchor` specifies the x position in terms of data or plot fraction but `x0`, `x1` and x
        /// coordinates within `path` are pixels relative to `xanchor`. This way, the shape can have a fixed
        /// width while maintaining a position relative to data or plot fraction.
        public var xSizeMode: XSizeMode? = nil
    
        /// Only relevant in conjunction with `xsizemode` set to *pixel*.
        /// 
        /// Specifies the anchor point on the x axis to which `x0`, `x1` and x coordinates within `path` are
        /// relative to. E.g. useful to attach a pixel sized shape to a certain data value. No effect when
        /// `xsizemode` not set to *pixel*.
        public var xAnchor: Anything? = nil
    
        /// Sets the shape's starting x position.
        /// 
        /// See `type` and `xsizemode` for more info.
        public var x0: Anything? = nil
    
        /// Sets the shape's end x position.
        /// 
        /// See `type` and `xsizemode` for more info.
        public var x1: Anything? = nil
    
        /// Sets the annotation's y coordinate axis.
        /// 
        /// If set to a y axis id (e.g. *y* or *y2*), the `y` position refers to a y coordinate. If set to
        /// *paper*, the `y` position refers to the distance from the bottom of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set to a y axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the bottom of the domain of that axis:
        /// e.g., *y2 domain* refers to the domain of the second y axis and a y position of 0.5 refers to
        /// the point between the bottom and the top of the domain of the second y axis.
        public var yReference: YAxisReference? = nil
    
        /// Sets the shapes's sizing mode along the y axis.
        /// 
        /// If set to *scaled*, `y0`, `y1` and y coordinates within `path` refer to data values on the y
        /// axis or a fraction of the plot area's height (`yref` set to *paper*). If set to *pixel*,
        /// `yanchor` specifies the y position in terms of data or plot fraction but `y0`, `y1` and y
        /// coordinates within `path` are pixels relative to `yanchor`. This way, the shape can have a fixed
        /// height while maintaining a position relative to data or plot fraction.
        public enum YSizeMode: String, Encodable {
            case scaled
            case pixel
        }
        /// Sets the shapes's sizing mode along the y axis.
        /// 
        /// If set to *scaled*, `y0`, `y1` and y coordinates within `path` refer to data values on the y
        /// axis or a fraction of the plot area's height (`yref` set to *paper*). If set to *pixel*,
        /// `yanchor` specifies the y position in terms of data or plot fraction but `y0`, `y1` and y
        /// coordinates within `path` are pixels relative to `yanchor`. This way, the shape can have a fixed
        /// height while maintaining a position relative to data or plot fraction.
        public var ySizeMode: YSizeMode? = nil
    
        /// Only relevant in conjunction with `ysizemode` set to *pixel*.
        /// 
        /// Specifies the anchor point on the y axis to which `y0`, `y1` and y coordinates within `path` are
        /// relative to. E.g. useful to attach a pixel sized shape to a certain data value. No effect when
        /// `ysizemode` not set to *pixel*.
        public var yAnchor: Anything? = nil
    
        /// Sets the shape's starting y position.
        /// 
        /// See `type` and `ysizemode` for more info.
        public var y0: Anything? = nil
    
        /// Sets the shape's end y position.
        /// 
        /// See `type` and `ysizemode` for more info.
        public var y1: Anything? = nil
    
        /// For `type` *path* - a valid SVG path with the pixel values replaced by data values in
        /// `xsizemode`/`ysizemode` being *scaled* and taken unmodified as pixels relative to `xanchor` and
        /// `yanchor` in case of *pixel* size mode.
        /// 
        /// There are a few restrictions / quirks only absolute instructions, not relative. So the allowed
        /// segments are: M, L, H, V, Q, C, T, S, and Z arcs (A) are not allowed because radius rx and ry
        /// are relative. In the future we could consider supporting relative commands, but we would have to
        /// decide on how to handle date and log axes. Note that even as is, Q and C Bezier paths that are
        /// smooth on linear axes may not be smooth on log, and vice versa. no chained "polybezier" commands
        /// - specify the segment type for each one. On category axes, values are numbers scaled to the
        /// serial numbers of categories because using the categories themselves there would be no way to
        /// describe fractional positions On data axes: because space and T are both normal components of
        /// path strings, we can't use either to separate date from time parts. Therefore we'll use
        /// underscore for this purpose: 2015-02-21_13:45:56.789
        public var path: String? = nil
    
        /// Sets the opacity of the shape.
        public var opacity: Double? = nil
    
        public var line: DashedLine? = nil
    
        /// Sets the color filling the shape's interior.
        /// 
        /// Only applies to closed shapes.
        public var fillColor: Color? = nil
    
        /// Determines which regions of complex paths constitute the interior.
        /// 
        /// For more info please visit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule
        public enum FillRule: String, Encodable {
            case evenOdd = "evenodd"
            case nonZero = "nonzero"
        }
        /// Determines which regions of complex paths constitute the interior.
        /// 
        /// For more info please visit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule
        public var fillRule: FillRule? = nil
    
        /// Determines whether the shape could be activated for edit or not.
        /// 
        /// Has no effect when the older editable shapes mode is enabled via `config.editable` or
        /// `config.edits.shapePosition`.
        public var editable: Bool? = nil
    
        /// When used in a template, named items are created in the output figure in addition to any items
        /// the figure already has in this array.
        /// 
        /// You can modify these items in the output figure by making your own item with `templateitemname`
        /// matching this `name` alongside your modifications (including `visible: false` or `enabled:
        /// false` to hide it). Has no effect outside of a template.
        public var name: String? = nil
    
        /// Used to refer to a named item in this array in the template.
        /// 
        /// Named items from the template will be created even without a matching item in the input figure,
        /// but you can modify one by making an item with `templateitemname` matching its `name`, alongside
        /// your modifications (including `visible: false` or `enabled: false` to hide it). If there is no
        /// template or no matching item, this item will be hidden unless you explicitly show it with
        /// `visible: true`.
        public var templateItemName: String? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case visible
            case type
            case layer
            case xReference = "xref"
            case xSizeMode = "xsizemode"
            case xAnchor = "xanchor"
            case x0
            case x1
            case yReference = "yref"
            case ySizeMode = "ysizemode"
            case yAnchor = "yanchor"
            case y0
            case y1
            case path
            case opacity
            case line
            case fillColor = "fillcolor"
            case fillRule = "fillrule"
            case editable
            case name
            case templateItemName = "templateitemname"
        }
        
        /// Creates `Shape` object with specified properties.
        /// 
        /// - Parameters:
        ///   - visible: Determines whether or not this shape is visible.
        ///   - type: Specifies the shape type to be drawn.
        ///   - layer: Specifies whether shapes are drawn below or above traces.
        ///   - xReference: Sets the shape's x coordinate axis.
        ///   - xSizeMode: Sets the shapes's sizing mode along the x axis.
        ///   - xAnchor: Only relevant in conjunction with `xsizemode` set to *pixel*.
        ///   - x0: Sets the shape's starting x position.
        ///   - x1: Sets the shape's end x position.
        ///   - yReference: Sets the annotation's y coordinate axis.
        ///   - ySizeMode: Sets the shapes's sizing mode along the y axis.
        ///   - yAnchor: Only relevant in conjunction with `ysizemode` set to *pixel*.
        ///   - y0: Sets the shape's starting y position.
        ///   - y1: Sets the shape's end y position.
        ///   - path: For `type` *path* - a valid SVG path with the pixel values replaced by data values in
        ///   `xsizemode`/`ysizemode` being *scaled* and taken unmodified as pixels relative to `xanchor` and
        ///   `yanchor` in case of *pixel* size mode.
        ///   - opacity: Sets the opacity of the shape.
        ///   - line:
        ///   - fillColor: Sets the color filling the shape's interior.
        ///   - fillRule: Determines which regions of complex paths constitute the interior.
        ///   - editable: Determines whether the shape could be activated for edit or not.
        ///   - name: When used in a template, named items are created in the output figure in addition to any
        ///   items the figure already has in this array.
        ///   - templateItemName: Used to refer to a named item in this array in the template.
        public init(visible: Bool? = nil, type: `Type`? = nil, layer: ShapeLayer? = nil, xReference:
                XAxisReference? = nil, xSizeMode: XSizeMode? = nil, xAnchor: Anything? = nil, x0: Anything? =
                nil, x1: Anything? = nil, yReference: YAxisReference? = nil, ySizeMode: YSizeMode? = nil,
                yAnchor: Anything? = nil, y0: Anything? = nil, y1: Anything? = nil, path: String? = nil,
                opacity: Double? = nil, line: DashedLine? = nil, fillColor: Color? = nil, fillRule: FillRule? =
                nil, editable: Bool? = nil, name: String? = nil, templateItemName: String? = nil) {
            self.visible = visible
            self.type = type
            self.layer = layer
            self.xReference = xReference
            self.xSizeMode = xSizeMode
            self.xAnchor = xAnchor
            self.x0 = x0
            self.x1 = x1
            self.yReference = yReference
            self.ySizeMode = ySizeMode
            self.yAnchor = yAnchor
            self.y0 = y0
            self.y1 = y1
            self.path = path
            self.opacity = opacity
            self.line = line
            self.fillColor = fillColor
            self.fillRule = fillRule
            self.editable = editable
            self.name = name
            self.templateItemName = templateItemName
        }
        
    }
    public var shapes: [Shape]? = nil

    public struct Image: Encodable {
        /// Determines whether or not this image is visible.
        public var visible: Bool? = nil
    
        /// Specifies the URL of the image to be used.
        /// 
        /// The URL must be accessible from the domain where the plot code is run, and can be either
        /// relative or absolute.
        public var source: String? = nil
    
        /// Specifies whether images are drawn below or above traces.
        /// 
        /// When `xref` and `yref` are both set to `paper`, image is drawn below the entire plot area.
        public var layer: ShapeLayer? = nil
    
        /// Sets the image container size horizontally.
        /// 
        /// The image will be sized based on the `position` value. When `xref` is set to `paper`, units are
        /// sized relative to the plot width. When `xref` ends with ` domain`, units are sized relative to
        /// the axis width.
        public var xSize: Double? = nil
    
        /// Sets the image container size vertically.
        /// 
        /// The image will be sized based on the `position` value. When `yref` is set to `paper`, units are
        /// sized relative to the plot height. When `yref` ends with ` domain`, units are sized relative to
        /// the axis height.
        public var ySize: Double? = nil
    
        /// Specifies which dimension of the image to constrain.
        public enum Sizing: String, Encodable {
            case fill
            case contain
            case stretch
        }
        /// Specifies which dimension of the image to constrain.
        public var sizing: Sizing? = nil
    
        /// Sets the opacity of the image.
        public var opacity: Double? = nil
    
        /// Sets the image's x position.
        /// 
        /// When `xref` is set to `paper`, units are sized relative to the plot height. See `xref` for more
        /// info
        public var x: Anything? = nil
    
        /// Sets the image's y position.
        /// 
        /// When `yref` is set to `paper`, units are sized relative to the plot height. See `yref` for more
        /// info
        public var y: Anything? = nil
    
        /// Sets the anchor for the x position
        public var xAnchor: XAnchor? = nil
    
        /// Sets the anchor for the y position.
        public var yAnchor: YAnchor? = nil
    
        /// Sets the images's x coordinate axis.
        /// 
        /// If set to a x axis id (e.g. *x* or *x2*), the `x` position refers to a x coordinate. If set to
        /// *paper*, the `x` position refers to the distance from the left of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the left (right). If set to a x axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the left of the domain of that axis:
        /// e.g., *x2 domain* refers to the domain of the second x axis and a x position of 0.5 refers to
        /// the point between the left and the right of the domain of the second x axis.
        public var xReference: XAxisReference? = nil
    
        /// Sets the images's y coordinate axis.
        /// 
        /// If set to a y axis id (e.g. *y* or *y2*), the `y` position refers to a y coordinate. If set to
        /// *paper*, the `y` position refers to the distance from the bottom of the plotting area in
        /// normalized coordinates where *0* (*1*) corresponds to the bottom (top). If set to a y axis ID
        /// followed by *domain* (separated by a space), the position behaves like for *paper*, but refers
        /// to the distance in fractions of the domain length from the bottom of the domain of that axis:
        /// e.g., *y2 domain* refers to the domain of the second y axis and a y position of 0.5 refers to
        /// the point between the bottom and the top of the domain of the second y axis.
        public var yReference: YAxisReference? = nil
    
        /// When used in a template, named items are created in the output figure in addition to any items
        /// the figure already has in this array.
        /// 
        /// You can modify these items in the output figure by making your own item with `templateitemname`
        /// matching this `name` alongside your modifications (including `visible: false` or `enabled:
        /// false` to hide it). Has no effect outside of a template.
        public var name: String? = nil
    
        /// Used to refer to a named item in this array in the template.
        /// 
        /// Named items from the template will be created even without a matching item in the input figure,
        /// but you can modify one by making an item with `templateitemname` matching its `name`, alongside
        /// your modifications (including `visible: false` or `enabled: false` to hide it). If there is no
        /// template or no matching item, this item will be hidden unless you explicitly show it with
        /// `visible: true`.
        public var templateItemName: String? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case visible
            case source
            case layer
            case xSize = "sizex"
            case ySize = "sizey"
            case sizing
            case opacity
            case x
            case y
            case xAnchor = "xanchor"
            case yAnchor = "yanchor"
            case xReference = "xref"
            case yReference = "yref"
            case name
            case templateItemName = "templateitemname"
        }
        
        /// Creates `Image` object with specified properties.
        /// 
        /// - Parameters:
        ///   - visible: Determines whether or not this image is visible.
        ///   - source: Specifies the URL of the image to be used.
        ///   - layer: Specifies whether images are drawn below or above traces.
        ///   - xSize: Sets the image container size horizontally.
        ///   - ySize: Sets the image container size vertically.
        ///   - sizing: Specifies which dimension of the image to constrain.
        ///   - opacity: Sets the opacity of the image.
        ///   - x: Sets the image's x position.
        ///   - y: Sets the image's y position.
        ///   - xAnchor: Sets the anchor for the x position
        ///   - yAnchor: Sets the anchor for the y position.
        ///   - xReference: Sets the images's x coordinate axis.
        ///   - yReference: Sets the images's y coordinate axis.
        ///   - name: When used in a template, named items are created in the output figure in addition to any
        ///   items the figure already has in this array.
        ///   - templateItemName: Used to refer to a named item in this array in the template.
        public init(visible: Bool? = nil, source: String? = nil, layer: ShapeLayer? = nil, xSize:
                Double? = nil, ySize: Double? = nil, sizing: Sizing? = nil, opacity: Double? = nil, x: Anything?
                = nil, y: Anything? = nil, xAnchor: XAnchor? = nil, yAnchor: YAnchor? = nil, xReference:
                XAxisReference? = nil, yReference: YAxisReference? = nil, name: String? = nil, templateItemName:
                String? = nil) {
            self.visible = visible
            self.source = source
            self.layer = layer
            self.xSize = xSize
            self.ySize = ySize
            self.sizing = sizing
            self.opacity = opacity
            self.x = x
            self.y = y
            self.xAnchor = xAnchor
            self.yAnchor = yAnchor
            self.xReference = xReference
            self.yReference = yReference
            self.name = name
            self.templateItemName = templateItemName
        }
        
    }
    public var images: [Image]? = nil

    public struct UpdateMenu: Encodable {
        /// Determines whether or not the update menu is visible.
        public var visible: Bool? = nil
    
        /// Determines whether the buttons are accessible via a dropdown menu or whether the buttons are
        /// stacked horizontally or vertically
        public enum `Type`: String, Encodable {
            case dropDown = "dropdown"
            case buttons
        }
        /// Determines whether the buttons are accessible via a dropdown menu or whether the buttons are
        /// stacked horizontally or vertically
        public var type: `Type`? = nil
    
        /// Determines the direction in which the buttons are laid out, whether in a dropdown menu or a
        /// row/column of buttons.
        /// 
        /// For `left` and `up`, the buttons will still appear in left-to-right or top-to-bottom order
        /// respectively.
        public enum Direction: String, Encodable {
            case left
            case right
            case up
            case down
        }
        /// Determines the direction in which the buttons are laid out, whether in a dropdown menu or a
        /// row/column of buttons.
        /// 
        /// For `left` and `up`, the buttons will still appear in left-to-right or top-to-bottom order
        /// respectively.
        public var direction: Direction? = nil
    
        /// Determines which button (by index starting from 0) is considered active.
        public var active: Int? = nil
    
        /// Highlights active dropdown item or active button if true.
        public var showActive: Bool? = nil
    
        public struct Button: Encodable {
            /// Determines whether or not this button is visible.
            public var visible: Bool? = nil
        
            /// Sets the Plotly method to be called on click.
            /// 
            /// If the `skip` method is used, the API updatemenu will function as normal but will perform no API
            /// calls and will not bind automatically to state updates. This may be used to create a component
            /// interface and attach to updatemenu events manually via JavaScript.
            public enum Method: String, Encodable {
                case restyle
                case relayout
                case animate
                case update
                case skip
            }
            /// Sets the Plotly method to be called on click.
            /// 
            /// If the `skip` method is used, the API updatemenu will function as normal but will perform no API
            /// calls and will not bind automatically to state updates. This may be used to create a component
            /// interface and attach to updatemenu events manually via JavaScript.
            public var method: Method? = nil
        
            /// Sets the arguments values to be passed to the Plotly method set in `method` on click.
            public var args: InfoArray? = nil
        
            /// Sets a 2nd set of `args`, these arguments values are passed to the Plotly method set in `method`
            /// when clicking this button while in the active state.
            /// 
            /// Use this to create toggle buttons.
            public var args2: InfoArray? = nil
        
            /// Sets the text label to appear on the button.
            public var label: String? = nil
        
            /// When true, the API method is executed.
            /// 
            /// When false, all other behaviors are the same and command execution is skipped. This may be
            /// useful when hooking into, for example, the `plotly_buttonclicked` method and executing the API
            /// command manually without losing the benefit of the updatemenu automatically binding to the state
            /// of the plot through the specification of `method` and `args`.
            public var execute: Bool? = nil
        
            /// When used in a template, named items are created in the output figure in addition to any items
            /// the figure already has in this array.
            /// 
            /// You can modify these items in the output figure by making your own item with `templateitemname`
            /// matching this `name` alongside your modifications (including `visible: false` or `enabled:
            /// false` to hide it). Has no effect outside of a template.
            public var name: String? = nil
        
            /// Used to refer to a named item in this array in the template.
            /// 
            /// Named items from the template will be created even without a matching item in the input figure,
            /// but you can modify one by making an item with `templateitemname` matching its `name`, alongside
            /// your modifications (including `visible: false` or `enabled: false` to hide it). If there is no
            /// template or no matching item, this item will be hidden unless you explicitly show it with
            /// `visible: true`.
            public var templateItemName: String? = nil
        
            /// Decoding and encoding keys compatible with Plotly schema.
            enum CodingKeys: String, CodingKey {
                case visible
                case method
                case args
                case args2
                case label
                case execute
                case name
                case templateItemName = "templateitemname"
            }
            
            /// Creates `Button` object with specified properties.
            /// 
            /// - Parameters:
            ///   - visible: Determines whether or not this button is visible.
            ///   - method: Sets the Plotly method to be called on click.
            ///   - args: Sets the arguments values to be passed to the Plotly method set in `method` on click.
            ///   - args2: Sets a 2nd set of `args`, these arguments values are passed to the Plotly method set in
            ///   `method` when clicking this button while in the active state.
            ///   - label: Sets the text label to appear on the button.
            ///   - execute: When true, the API method is executed.
            ///   - name: When used in a template, named items are created in the output figure in addition to any
            ///   items the figure already has in this array.
            ///   - templateItemName: Used to refer to a named item in this array in the template.
            public init(visible: Bool? = nil, method: Method? = nil, args: InfoArray? = nil, args2:
                    InfoArray? = nil, label: String? = nil, execute: Bool? = nil, name: String? = nil,
                    templateItemName: String? = nil) {
                self.visible = visible
                self.method = method
                self.args = args
                self.args2 = args2
                self.label = label
                self.execute = execute
                self.name = name
                self.templateItemName = templateItemName
            }
            
        }
        public var buttons: [Button]? = nil
    
        /// Sets the x position (in normalized coordinates) of the update menu.
        public var x: Double? = nil
    
        /// Sets the update menu's horizontal position anchor.
        /// 
        /// This anchor binds the `x` position to the *left*, *center* or *right* of the range selector.
        public var xAnchor: XAutoAnchor? = nil
    
        /// Sets the y position (in normalized coordinates) of the update menu.
        public var y: Double? = nil
    
        /// Sets the update menu's vertical position anchor This anchor binds the `y` position to the *top*,
        /// *middle* or *bottom* of the range selector.
        public var yAnchor: YAutoAnchor? = nil
    
        /// Sets the padding around the buttons or dropdown menu.
        public var padding: Padding? = nil
    
        /// Sets the font of the update menu button text.
        public var font: Font? = nil
    
        /// Sets the background color of the update menu buttons.
        public var backgroundColor: Color? = nil
    
        /// Sets the color of the border enclosing the update menu.
        public var borderColor: Color? = nil
    
        /// Sets the width (in px) of the border enclosing the update menu.
        public var borderWidth: Double? = nil
    
        /// When used in a template, named items are created in the output figure in addition to any items
        /// the figure already has in this array.
        /// 
        /// You can modify these items in the output figure by making your own item with `templateitemname`
        /// matching this `name` alongside your modifications (including `visible: false` or `enabled:
        /// false` to hide it). Has no effect outside of a template.
        public var name: String? = nil
    
        /// Used to refer to a named item in this array in the template.
        /// 
        /// Named items from the template will be created even without a matching item in the input figure,
        /// but you can modify one by making an item with `templateitemname` matching its `name`, alongside
        /// your modifications (including `visible: false` or `enabled: false` to hide it). If there is no
        /// template or no matching item, this item will be hidden unless you explicitly show it with
        /// `visible: true`.
        public var templateItemName: String? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case visible
            case type
            case direction
            case active
            case showActive = "showactive"
            case buttons
            case x
            case xAnchor = "xanchor"
            case y
            case yAnchor = "yanchor"
            case padding = "pad"
            case font
            case backgroundColor = "bgcolor"
            case borderColor = "bordercolor"
            case borderWidth = "borderwidth"
            case name
            case templateItemName = "templateitemname"
        }
        
        /// Creates `UpdateMenu` object with specified properties.
        /// 
        /// - Parameters:
        ///   - visible: Determines whether or not the update menu is visible.
        ///   - type: Determines whether the buttons are accessible via a dropdown menu or whether the buttons
        ///   are stacked horizontally or vertically
        ///   - direction: Determines the direction in which the buttons are laid out, whether in a dropdown
        ///   menu or a row/column of buttons.
        ///   - active: Determines which button (by index starting from 0) is considered active.
        ///   - showActive: Highlights active dropdown item or active button if true.
        ///   - buttons:
        ///   - x: Sets the x position (in normalized coordinates) of the update menu.
        ///   - xAnchor: Sets the update menu's horizontal position anchor.
        ///   - y: Sets the y position (in normalized coordinates) of the update menu.
        ///   - yAnchor: Sets the update menu's vertical position anchor This anchor binds the `y` position to
        ///   the *top*, *middle* or *bottom* of the range selector.
        ///   - padding: Sets the padding around the buttons or dropdown menu.
        ///   - font: Sets the font of the update menu button text.
        ///   - backgroundColor: Sets the background color of the update menu buttons.
        ///   - borderColor: Sets the color of the border enclosing the update menu.
        ///   - borderWidth: Sets the width (in px) of the border enclosing the update menu.
        ///   - name: When used in a template, named items are created in the output figure in addition to any
        ///   items the figure already has in this array.
        ///   - templateItemName: Used to refer to a named item in this array in the template.
        public init(visible: Bool? = nil, type: `Type`? = nil, direction: Direction? = nil, active: Int?
                = nil, showActive: Bool? = nil, buttons: [Button]? = nil, x: Double? = nil, xAnchor:
                XAutoAnchor? = nil, y: Double? = nil, yAnchor: YAutoAnchor? = nil, padding: Padding? = nil,
                font: Font? = nil, backgroundColor: Color? = nil, borderColor: Color? = nil, borderWidth:
                Double? = nil, name: String? = nil, templateItemName: String? = nil) {
            self.visible = visible
            self.type = type
            self.direction = direction
            self.active = active
            self.showActive = showActive
            self.buttons = buttons
            self.x = x
            self.xAnchor = xAnchor
            self.y = y
            self.yAnchor = yAnchor
            self.padding = padding
            self.font = font
            self.backgroundColor = backgroundColor
            self.borderColor = borderColor
            self.borderWidth = borderWidth
            self.name = name
            self.templateItemName = templateItemName
        }
        
    }
    public var updateMenus: [UpdateMenu]? = nil

    public struct Slider: Encodable {
        /// Determines whether or not the slider is visible.
        public var visible: Bool? = nil
    
        /// Determines which button (by index starting from 0) is considered active.
        public var active: Double? = nil
    
        public struct Step: Encodable {
            /// Determines whether or not this step is included in the slider.
            public var visible: Bool? = nil
        
            /// Sets the Plotly method to be called when the slider value is changed.
            /// 
            /// If the `skip` method is used, the API slider will function as normal but will perform no API
            /// calls and will not bind automatically to state updates. This may be used to create a component
            /// interface and attach to slider events manually via JavaScript.
            public enum Method: String, Encodable {
                case restyle
                case relayout
                case animate
                case update
                case skip
            }
            /// Sets the Plotly method to be called when the slider value is changed.
            /// 
            /// If the `skip` method is used, the API slider will function as normal but will perform no API
            /// calls and will not bind automatically to state updates. This may be used to create a component
            /// interface and attach to slider events manually via JavaScript.
            public var method: Method? = nil
        
            /// Sets the arguments values to be passed to the Plotly method set in `method` on slide.
            public var args: InfoArray? = nil
        
            /// Sets the text label to appear on the slider
            public var label: String? = nil
        
            /// Sets the value of the slider step, used to refer to the step programatically.
            /// 
            /// Defaults to the slider label if not provided.
            public var value: String? = nil
        
            /// When true, the API method is executed.
            /// 
            /// When false, all other behaviors are the same and command execution is skipped. This may be
            /// useful when hooking into, for example, the `plotly_sliderchange` method and executing the API
            /// command manually without losing the benefit of the slider automatically binding to the state of
            /// the plot through the specification of `method` and `args`.
            public var execute: Bool? = nil
        
            /// When used in a template, named items are created in the output figure in addition to any items
            /// the figure already has in this array.
            /// 
            /// You can modify these items in the output figure by making your own item with `templateitemname`
            /// matching this `name` alongside your modifications (including `visible: false` or `enabled:
            /// false` to hide it). Has no effect outside of a template.
            public var name: String? = nil
        
            /// Used to refer to a named item in this array in the template.
            /// 
            /// Named items from the template will be created even without a matching item in the input figure,
            /// but you can modify one by making an item with `templateitemname` matching its `name`, alongside
            /// your modifications (including `visible: false` or `enabled: false` to hide it). If there is no
            /// template or no matching item, this item will be hidden unless you explicitly show it with
            /// `visible: true`.
            public var templateItemName: String? = nil
        
            /// Decoding and encoding keys compatible with Plotly schema.
            enum CodingKeys: String, CodingKey {
                case visible
                case method
                case args
                case label
                case value
                case execute
                case name
                case templateItemName = "templateitemname"
            }
            
            /// Creates `Step` object with specified properties.
            /// 
            /// - Parameters:
            ///   - visible: Determines whether or not this step is included in the slider.
            ///   - method: Sets the Plotly method to be called when the slider value is changed.
            ///   - args: Sets the arguments values to be passed to the Plotly method set in `method` on slide.
            ///   - label: Sets the text label to appear on the slider
            ///   - value: Sets the value of the slider step, used to refer to the step programatically.
            ///   - execute: When true, the API method is executed.
            ///   - name: When used in a template, named items are created in the output figure in addition to any
            ///   items the figure already has in this array.
            ///   - templateItemName: Used to refer to a named item in this array in the template.
            public init(visible: Bool? = nil, method: Method? = nil, args: InfoArray? = nil, label: String?
                    = nil, value: String? = nil, execute: Bool? = nil, name: String? = nil, templateItemName:
                    String? = nil) {
                self.visible = visible
                self.method = method
                self.args = args
                self.label = label
                self.value = value
                self.execute = execute
                self.name = name
                self.templateItemName = templateItemName
            }
            
        }
        public var steps: [Step]? = nil
    
        /// Determines whether this slider length is set in units of plot *fraction* or in *pixels.
        /// 
        /// Use `len` to set the value.
        public var lengthMode: LengthMode? = nil
    
        /// Sets the length of the slider This measure excludes the padding of both ends.
        /// 
        /// That is, the slider's length is this length minus the padding on both ends.
        public var length: Double? = nil
    
        /// Sets the x position (in normalized coordinates) of the slider.
        public var x: Double? = nil
    
        /// Set the padding of the slider component along each side.
        public var padding: Padding? = nil
    
        /// Sets the slider's horizontal position anchor.
        /// 
        /// This anchor binds the `x` position to the *left*, *center* or *right* of the range selector.
        public var xAnchor: XAutoAnchor? = nil
    
        /// Sets the y position (in normalized coordinates) of the slider.
        public var y: Double? = nil
    
        /// Sets the slider's vertical position anchor This anchor binds the `y` position to the *top*,
        /// *middle* or *bottom* of the range selector.
        public var yAnchor: YAutoAnchor? = nil
    
        public struct Transition: Encodable {
            /// Sets the duration of the slider transition
            public var duration: Double? = nil
        
            /// Sets the easing function of the slider transition
            public var easing: Easing? = nil
        
            /// Creates `Transition` object with specified properties.
            /// 
            /// - Parameters:
            ///   - duration: Sets the duration of the slider transition
            ///   - easing: Sets the easing function of the slider transition
            public init(duration: Double? = nil, easing: Easing? = nil) {
                self.duration = duration
                self.easing = easing
            }
            
        }
        public var transition: Transition? = nil
    
        public struct CurrentValue: Encodable {
            /// Shows the currently-selected value above the slider.
            public var visible: Bool? = nil
        
            /// The alignment of the value readout relative to the length of the slider.
            public var xAnchor: XAnchor? = nil
        
            /// The amount of space, in pixels, between the current value label and the slider.
            public var offset: Double? = nil
        
            /// When currentvalue.visible is true, this sets the prefix of the label.
            public var prefix: String? = nil
        
            /// When currentvalue.visible is true, this sets the suffix of the label.
            public var suffix: String? = nil
        
            /// Sets the font of the current value label text.
            public var font: Font? = nil
        
            /// Decoding and encoding keys compatible with Plotly schema.
            enum CodingKeys: String, CodingKey {
                case visible
                case xAnchor = "xanchor"
                case offset
                case prefix
                case suffix
                case font
            }
            
            /// Creates `CurrentValue` object with specified properties.
            /// 
            /// - Parameters:
            ///   - visible: Shows the currently-selected value above the slider.
            ///   - xAnchor: The alignment of the value readout relative to the length of the slider.
            ///   - offset: The amount of space, in pixels, between the current value label and the slider.
            ///   - prefix: When currentvalue.visible is true, this sets the prefix of the label.
            ///   - suffix: When currentvalue.visible is true, this sets the suffix of the label.
            ///   - font: Sets the font of the current value label text.
            public init(visible: Bool? = nil, xAnchor: XAnchor? = nil, offset: Double? = nil, prefix:
                    String? = nil, suffix: String? = nil, font: Font? = nil) {
                self.visible = visible
                self.xAnchor = xAnchor
                self.offset = offset
                self.prefix = prefix
                self.suffix = suffix
                self.font = font
            }
            
        }
        public var currentValue: CurrentValue? = nil
    
        /// Sets the font of the slider step labels.
        public var font: Font? = nil
    
        /// Sets the background color of the slider grip while dragging.
        public var activeBackgroundColor: Color? = nil
    
        /// Sets the background color of the slider.
        public var backgroundColor: Color? = nil
    
        /// Sets the color of the border enclosing the slider.
        public var borderColor: Color? = nil
    
        /// Sets the width (in px) of the border enclosing the slider.
        public var borderWidth: Double? = nil
    
        /// Sets the length in pixels of step tick marks
        public var tickLength: Double? = nil
    
        /// Sets the color of the border enclosing the slider.
        public var tickColor: Color? = nil
    
        /// Sets the tick width (in px).
        public var tickWidth: Double? = nil
    
        /// Sets the length in pixels of minor step tick marks
        public var minorTickLength: Double? = nil
    
        /// When used in a template, named items are created in the output figure in addition to any items
        /// the figure already has in this array.
        /// 
        /// You can modify these items in the output figure by making your own item with `templateitemname`
        /// matching this `name` alongside your modifications (including `visible: false` or `enabled:
        /// false` to hide it). Has no effect outside of a template.
        public var name: String? = nil
    
        /// Used to refer to a named item in this array in the template.
        /// 
        /// Named items from the template will be created even without a matching item in the input figure,
        /// but you can modify one by making an item with `templateitemname` matching its `name`, alongside
        /// your modifications (including `visible: false` or `enabled: false` to hide it). If there is no
        /// template or no matching item, this item will be hidden unless you explicitly show it with
        /// `visible: true`.
        public var templateItemName: String? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case visible
            case active
            case steps
            case lengthMode = "lenmode"
            case length = "len"
            case x
            case padding = "pad"
            case xAnchor = "xanchor"
            case y
            case yAnchor = "yanchor"
            case transition
            case currentValue = "currentvalue"
            case font
            case activeBackgroundColor = "activebgcolor"
            case backgroundColor = "bgcolor"
            case borderColor = "bordercolor"
            case borderWidth = "borderwidth"
            case tickLength = "ticklen"
            case tickColor = "tickcolor"
            case tickWidth = "tickwidth"
            case minorTickLength = "minorticklen"
            case name
            case templateItemName = "templateitemname"
        }
        
        /// Creates `Slider` object with specified properties.
        /// 
        /// - Parameters:
        ///   - visible: Determines whether or not the slider is visible.
        ///   - active: Determines which button (by index starting from 0) is considered active.
        ///   - steps:
        ///   - lengthMode: Determines whether this slider length is set in units of plot *fraction* or in
        ///   *pixels.
        ///   - length: Sets the length of the slider This measure excludes the padding of both ends.
        ///   - x: Sets the x position (in normalized coordinates) of the slider.
        ///   - padding: Set the padding of the slider component along each side.
        ///   - xAnchor: Sets the slider's horizontal position anchor.
        ///   - y: Sets the y position (in normalized coordinates) of the slider.
        ///   - yAnchor: Sets the slider's vertical position anchor This anchor binds the `y` position to the
        ///   *top*, *middle* or *bottom* of the range selector.
        ///   - transition:
        ///   - currentValue:
        ///   - font: Sets the font of the slider step labels.
        ///   - activeBackgroundColor: Sets the background color of the slider grip while dragging.
        ///   - backgroundColor: Sets the background color of the slider.
        ///   - borderColor: Sets the color of the border enclosing the slider.
        ///   - borderWidth: Sets the width (in px) of the border enclosing the slider.
        ///   - tickLength: Sets the length in pixels of step tick marks
        ///   - tickColor: Sets the color of the border enclosing the slider.
        ///   - tickWidth: Sets the tick width (in px).
        ///   - minorTickLength: Sets the length in pixels of minor step tick marks
        ///   - name: When used in a template, named items are created in the output figure in addition to any
        ///   items the figure already has in this array.
        ///   - templateItemName: Used to refer to a named item in this array in the template.
        public init(visible: Bool? = nil, active: Double? = nil, steps: [Step]? = nil, lengthMode:
                LengthMode? = nil, length: Double? = nil, x: Double? = nil, padding: Padding? = nil, xAnchor:
                XAutoAnchor? = nil, y: Double? = nil, yAnchor: YAutoAnchor? = nil, transition: Transition? =
                nil, currentValue: CurrentValue? = nil, font: Font? = nil, activeBackgroundColor: Color? = nil,
                backgroundColor: Color? = nil, borderColor: Color? = nil, borderWidth: Double? = nil,
                tickLength: Double? = nil, tickColor: Color? = nil, tickWidth: Double? = nil, minorTickLength:
                Double? = nil, name: String? = nil, templateItemName: String? = nil) {
            self.visible = visible
            self.active = active
            self.steps = steps
            self.lengthMode = lengthMode
            self.length = length
            self.x = x
            self.padding = padding
            self.xAnchor = xAnchor
            self.y = y
            self.yAnchor = yAnchor
            self.transition = transition
            self.currentValue = currentValue
            self.font = font
            self.activeBackgroundColor = activeBackgroundColor
            self.backgroundColor = backgroundColor
            self.borderColor = borderColor
            self.borderWidth = borderWidth
            self.tickLength = tickLength
            self.tickColor = tickColor
            self.tickWidth = tickWidth
            self.minorTickLength = minorTickLength
            self.name = name
            self.templateItemName = templateItemName
        }
        
    }
    public var sliders: [Slider]? = nil

    
    // MARK: - Color Visualization

    public struct ColorMap: Encodable {
        /// Sets the default sequential colorscale for positive values.
        /// 
        /// Note that `autocolorscale` must be true for this attribute to work.
        public var sequential: ColorScale? = nil
    
        /// Sets the default sequential colorscale for negative values.
        /// 
        /// Note that `autocolorscale` must be true for this attribute to work.
        public var sequentialMinus: ColorScale? = nil
    
        /// Sets the default diverging colorscale.
        /// 
        /// Note that `autocolorscale` must be true for this attribute to work.
        public var diverging: ColorScale? = nil
    
        /// Decoding and encoding keys compatible with Plotly schema.
        enum CodingKeys: String, CodingKey {
            case sequential
            case sequentialMinus = "sequentialminus"
            case diverging
        }
        
        /// Creates `ColorMap` object with specified properties.
        /// 
        /// - Parameters:
        ///   - sequential: Sets the default sequential colorscale for positive values.
        ///   - sequentialMinus: Sets the default sequential colorscale for negative values.
        ///   - diverging: Sets the default diverging colorscale.
        public init(sequential: ColorScale? = nil, sequentialMinus: ColorScale? = nil, diverging:
                ColorScale? = nil) {
            self.sequential = sequential
            self.sequentialMinus = sequentialMinus
            self.diverging = diverging
        }
        
    }
    public var colorScale: ColorMap? = nil

    public var colorAxis: [ColorAxis] = []

    /// Decoding and encoding keys compatible with Plotly schema.
    enum CodingKeys: String, CodingKey {
        case funnelAreaColorWay = "funnelareacolorway"
        case extendFunnelAreaColors = "extendfunnelareacolors"
        case treemapColorWay = "treemapcolorway"
        case extendTreemapColors = "extendtreemapcolors"
        case sunburstColorWay = "sunburstcolorway"
        case extendSunburstColors = "extendsunburstcolors"
        case hiddenLabels = "hiddenlabels"
        case pieColorWay = "piecolorway"
        case extendPieColors = "extendpiecolors"
        case waterfallMode = "waterfallmode"
        case waterfallGap = "waterfallgap"
        case waterfallGroupGap = "waterfallgroupgap"
        case funnelMode = "funnelmode"
        case funnelGap = "funnelgap"
        case funnelGroupGap = "funnelgroupgap"
        case violinMode = "violinmode"
        case violinGap = "violingap"
        case violinGroupGap = "violingroupgap"
        case boxMode = "boxmode"
        case boxGap = "boxgap"
        case boxGroupGap = "boxgroupgap"
        case barMode = "barmode"
        case barNormalization = "barnorm"
        case barGap = "bargap"
        case barGroupGap = "bargroupgap"
        case font
        case title
        case uniformText = "uniformtext"
        case autoSize = "autosize"
        case width
        case height
        case margin
        case computed
        case paperBackgroundColor = "paper_bgcolor"
        case plotBackgroundColor = "plot_bgcolor"
        case autoTypeNumbers = "autotypenumbers"
        case separators
        case hideSources = "hidesources"
        case showLegend = "showlegend"
        case colorWay = "colorway"
        case dataRevision = "datarevision"
        case uiRevision = "uirevision"
        case editRevision = "editrevision"
        case selectionRevision = "selectionrevision"
        case template
        case modeBar = "modebar"
        case newShape = "newshape"
        case activeShape = "activeshape"
        case meta
        case transition
        case clickMode = "clickmode"
        case dragMode = "dragmode"
        case hoverMode = "hovermode"
        case hoverDistance = "hoverdistance"
        case spikeDistance = "spikedistance"
        case hoverLabel = "hoverlabel"
        case selectDirection = "selectdirection"
        case grid
        case calendar
        case xAxis = "xaxis"
        case yAxis = "yaxis"
        case ternary
        case scene
        case geo
        case mapbox
        case polar
        case legend
        case annotations
        case shapes
        case images
        case updateMenus = "updatemenus"
        case sliders
        case colorScale = "colorscale"
        case colorAxis = "coloraxis"
    }
    
    /// Creates `Layout` object with specified properties.
    /// 
    /// - Parameters:
    ///   - funnelAreaColorWay: Sets the default funnelarea slice colors.
    ///   - extendFunnelAreaColors: If `true`, the funnelarea slice colors (whether given by
    ///   `funnelareacolorway` or inherited from `colorway`) will be extended to three times its original
    ///   length by first repeating every color 20% lighter then each color 20% darker.
    ///   - treemapColorWay: Sets the default treemap slice colors.
    ///   - extendTreemapColors: If `true`, the treemap slice colors (whether given by `treemapcolorway`
    ///   or inherited from `colorway`) will be extended to three times its original length by first
    ///   repeating every color 20% lighter then each color 20% darker.
    ///   - sunburstColorWay: Sets the default sunburst slice colors.
    ///   - extendSunburstColors: If `true`, the sunburst slice colors (whether given by
    ///   `sunburstcolorway` or inherited from `colorway`) will be extended to three times its original
    ///   length by first repeating every color 20% lighter then each color 20% darker.
    ///   - hiddenLabels: hiddenlabels is the funnelarea & pie chart analog of visible:'legendonly' but it
    ///   can contain many labels, and can simultaneously hide slices from several pies/funnelarea charts
    ///   - pieColorWay: Sets the default pie slice colors.
    ///   - extendPieColors: If `true`, the pie slice colors (whether given by `piecolorway` or inherited
    ///   from `colorway`) will be extended to three times its original length by first repeating every
    ///   color 20% lighter then each color 20% darker.
    ///   - waterfallMode: Determines how bars at the same location coordinate are displayed on the graph.
    ///   - waterfallGap: Sets the gap (in plot fraction) between bars of adjacent location coordinates.
    ///   - waterfallGroupGap: Sets the gap (in plot fraction) between bars of the same location
    ///   coordinate.
    ///   - funnelMode: Determines how bars at the same location coordinate are displayed on the graph.
    ///   - funnelGap: Sets the gap (in plot fraction) between bars of adjacent location coordinates.
    ///   - funnelGroupGap: Sets the gap (in plot fraction) between bars of the same location coordinate.
    ///   - violinMode: Determines how violins at the same location coordinate are displayed on the graph.
    ///   - violinGap: Sets the gap (in plot fraction) between violins of adjacent location coordinates.
    ///   - violinGroupGap: Sets the gap (in plot fraction) between violins of the same location
    ///   coordinate.
    ///   - boxMode: Determines how boxes at the same location coordinate are displayed on the graph.
    ///   - boxGap: Sets the gap (in plot fraction) between boxes of adjacent location coordinates.
    ///   - boxGroupGap: Sets the gap (in plot fraction) between boxes of the same location coordinate.
    ///   - barMode: Determines how bars at the same location coordinate are displayed on the graph.
    ///   - barNormalization: Sets the normalization for bar traces on the graph.
    ///   - barGap: Sets the gap (in plot fraction) between bars of adjacent location coordinates.
    ///   - barGroupGap: Sets the gap (in plot fraction) between bars of the same location coordinate.
    ///   - font: Sets the global font.
    ///   - title:
    ///   - uniformText:
    ///   - autoSize: Determines whether or not a layout width or height that has been left undefined by
    ///   the user is initialized on each relayout.
    ///   - width: Sets the plot's width (in px).
    ///   - height: Sets the plot's height (in px).
    ///   - margin:
    ///   - computed: Placeholder for exporting automargin-impacting values namely `margin.t`, `margin.b`,
    ///   `margin.l` and `margin.r` in *full-json* mode.
    ///   - paperBackgroundColor: Sets the background color of the paper where the graph is drawn.
    ///   - plotBackgroundColor: Sets the background color of the plotting area in-between x and y axes.
    ///   - autoTypeNumbers: Using *strict* a numeric string in trace data is not converted to a number.
    ///   - separators: Sets the decimal and thousand separators.
    ///   - hideSources: Determines whether or not a text link citing the data source is placed at the
    ///   bottom-right cored of the figure.
    ///   - showLegend: Determines whether or not a legend is drawn.
    ///   - colorWay: Sets the default trace colors.
    ///   - dataRevision: If provided, a changed value tells `Plotly.react` that one or more data arrays
    ///   has changed.
    ///   - uiRevision: Used to allow user interactions with the plot to persist after `Plotly.react`
    ///   calls that are unaware of these interactions.
    ///   - editRevision: Controls persistence of user-driven changes in `editable: true` configuration,
    ///   other than trace names and axis titles.
    ///   - selectionRevision: Controls persistence of user-driven changes in selected points from all
    ///   traces.
    ///   - template: Default attributes to be applied to the plot.
    ///   - modeBar:
    ///   - newShape:
    ///   - activeShape:
    ///   - meta: Assigns extra meta information that can be used in various `text` attributes.
    ///   - transition: Sets transition options used during Plotly.react updates.
    ///   - clickMode: Determines the mode of single click interactions.
    ///   - dragMode: Determines the mode of drag interactions.
    ///   - hoverMode: Determines the mode of hover interactions.
    ///   - hoverDistance: Sets the default distance (in pixels) to look for data to add hover labels (-1
    ///   means no cutoff, 0 means no looking for data).
    ///   - spikeDistance: Sets the default distance (in pixels) to look for data to draw spikelines to
    ///   (-1 means no cutoff, 0 means no looking for data).
    ///   - hoverLabel:
    ///   - selectDirection: When `dragmode` is set to *select*, this limits the selection of the drag to
    ///   horizontal, vertical or diagonal.
    ///   - grid:
    ///   - calendar: Sets the default calendar system to use for interpreting and displaying dates
    ///   throughout the plot.
    ///   - xAxis:
    ///   - yAxis:
    ///   - ternary:
    ///   - scene:
    ///   - geo:
    ///   - mapbox:
    ///   - polar:
    ///   - legend:
    ///   - annotations:
    ///   - shapes:
    ///   - images:
    ///   - updateMenus:
    ///   - sliders:
    ///   - colorScale:
    ///   - colorAxis:
    public init(funnelAreaColorWay: ColorList? = nil, extendFunnelAreaColors: Bool? = nil,
            treemapColorWay: ColorList? = nil, extendTreemapColors: Bool? = nil, sunburstColorWay:
            ColorList? = nil, extendSunburstColors: Bool? = nil, hiddenLabels: [Double]? = nil, pieColorWay:
            ColorList? = nil, extendPieColors: Bool? = nil, waterfallMode: WaterfallMode? = nil,
            waterfallGap: Double? = nil, waterfallGroupGap: Double? = nil, funnelMode: FunnelMode? = nil,
            funnelGap: Double? = nil, funnelGroupGap: Double? = nil, violinMode: ViolinMode? = nil,
            violinGap: Double? = nil, violinGroupGap: Double? = nil, boxMode: BoxMode? = nil, boxGap:
            Double? = nil, boxGroupGap: Double? = nil, barMode: BarMode? = nil, barNormalization:
            BarNormalization? = nil, barGap: Double? = nil, barGroupGap: Double? = nil, font: Font? = nil,
            title: Title? = nil, uniformText: UniformText? = nil, autoSize: Bool? = nil, width: Double? =
            nil, height: Double? = nil, margin: Margin? = nil, computed: Anything? = nil,
            paperBackgroundColor: Color? = nil, plotBackgroundColor: Color? = nil, autoTypeNumbers:
            AutoTypeNumbers? = nil, separators: String? = nil, hideSources: Bool? = nil, showLegend: Bool? =
            nil, colorWay: ColorList? = nil, dataRevision: Anything? = nil, uiRevision: Anything? = nil,
            editRevision: Anything? = nil, selectionRevision: Anything? = nil, template: Anything? = nil,
            modeBar: ModeBar? = nil, newShape: NewShape? = nil, activeShape: ActiveShape? = nil, meta:
            Data<Anything>? = nil, transition: Transition? = nil, clickMode: ClickMode? = nil, dragMode:
            DragMode? = nil, hoverMode: HoverMode? = nil, hoverDistance: Int? = nil, spikeDistance: Int? =
            nil, hoverLabel: HoverLabel? = nil, selectDirection: SelectDirection? = nil, grid: Grid? = nil,
            calendar: Calendar? = nil, xAxis: [XAxis] = [], yAxis: [YAxis] = [], ternary: [Ternary] = [],
            scene: [Scene] = [], geo: [Geo] = [], mapbox: [Mapbox] = [], polar: [Polar] = [], legend:
            Legend? = nil, annotations: [Annotation]? = nil, shapes: [Shape]? = nil, images: [Image]? = nil,
            updateMenus: [UpdateMenu]? = nil, sliders: [Slider]? = nil, colorScale: ColorMap? = nil,
            colorAxis: [ColorAxis] = []) {
        self.funnelAreaColorWay = funnelAreaColorWay
        self.extendFunnelAreaColors = extendFunnelAreaColors
        self.treemapColorWay = treemapColorWay
        self.extendTreemapColors = extendTreemapColors
        self.sunburstColorWay = sunburstColorWay
        self.extendSunburstColors = extendSunburstColors
        self.hiddenLabels = hiddenLabels
        self.pieColorWay = pieColorWay
        self.extendPieColors = extendPieColors
        self.waterfallMode = waterfallMode
        self.waterfallGap = waterfallGap
        self.waterfallGroupGap = waterfallGroupGap
        self.funnelMode = funnelMode
        self.funnelGap = funnelGap
        self.funnelGroupGap = funnelGroupGap
        self.violinMode = violinMode
        self.violinGap = violinGap
        self.violinGroupGap = violinGroupGap
        self.boxMode = boxMode
        self.boxGap = boxGap
        self.boxGroupGap = boxGroupGap
        self.barMode = barMode
        self.barNormalization = barNormalization
        self.barGap = barGap
        self.barGroupGap = barGroupGap
        self.font = font
        self.title = title
        self.uniformText = uniformText
        self.autoSize = autoSize
        self.width = width
        self.height = height
        self.margin = margin
        self.computed = computed
        self.paperBackgroundColor = paperBackgroundColor
        self.plotBackgroundColor = plotBackgroundColor
        self.autoTypeNumbers = autoTypeNumbers
        self.separators = separators
        self.hideSources = hideSources
        self.showLegend = showLegend
        self.colorWay = colorWay
        self.dataRevision = dataRevision
        self.uiRevision = uiRevision
        self.editRevision = editRevision
        self.selectionRevision = selectionRevision
        self.template = template
        self.modeBar = modeBar
        self.newShape = newShape
        self.activeShape = activeShape
        self.meta = meta
        self.transition = transition
        self.clickMode = clickMode
        self.dragMode = dragMode
        self.hoverMode = hoverMode
        self.hoverDistance = hoverDistance
        self.spikeDistance = spikeDistance
        self.hoverLabel = hoverLabel
        self.selectDirection = selectDirection
        self.grid = grid
        self.calendar = calendar
        self.xAxis = xAxis
        self.yAxis = yAxis
        self.ternary = ternary
        self.scene = scene
        self.geo = geo
        self.mapbox = mapbox
        self.polar = polar
        self.legend = legend
        self.annotations = annotations
        self.shapes = shapes
        self.images = images
        self.updateMenus = updateMenus
        self.sliders = sliders
        self.colorScale = colorScale
        self.colorAxis = colorAxis
    }
    
    /// Encodes the object in a format compatible with Plotly.
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        var axisContainer = encoder.container(keyedBy: AxisKeys.self)
        try container.encodeIfPresent(funnelAreaColorWay, forKey: .funnelAreaColorWay)
        try container.encodeIfPresent(extendFunnelAreaColors, forKey: .extendFunnelAreaColors)
        try container.encodeIfPresent(treemapColorWay, forKey: .treemapColorWay)
        try container.encodeIfPresent(extendTreemapColors, forKey: .extendTreemapColors)
        try container.encodeIfPresent(sunburstColorWay, forKey: .sunburstColorWay)
        try container.encodeIfPresent(extendSunburstColors, forKey: .extendSunburstColors)
        try container.encodeIfPresent(hiddenLabels, forKey: .hiddenLabels)
        try container.encodeIfPresent(pieColorWay, forKey: .pieColorWay)
        try container.encodeIfPresent(extendPieColors, forKey: .extendPieColors)
        try container.encodeIfPresent(waterfallMode, forKey: .waterfallMode)
        try container.encodeIfPresent(waterfallGap, forKey: .waterfallGap)
        try container.encodeIfPresent(waterfallGroupGap, forKey: .waterfallGroupGap)
        try container.encodeIfPresent(funnelMode, forKey: .funnelMode)
        try container.encodeIfPresent(funnelGap, forKey: .funnelGap)
        try container.encodeIfPresent(funnelGroupGap, forKey: .funnelGroupGap)
        try container.encodeIfPresent(violinMode, forKey: .violinMode)
        try container.encodeIfPresent(violinGap, forKey: .violinGap)
        try container.encodeIfPresent(violinGroupGap, forKey: .violinGroupGap)
        try container.encodeIfPresent(boxMode, forKey: .boxMode)
        try container.encodeIfPresent(boxGap, forKey: .boxGap)
        try container.encodeIfPresent(boxGroupGap, forKey: .boxGroupGap)
        try container.encodeIfPresent(barMode, forKey: .barMode)
        try container.encodeIfPresent(barNormalization, forKey: .barNormalization)
        try container.encodeIfPresent(barGap, forKey: .barGap)
        try container.encodeIfPresent(barGroupGap, forKey: .barGroupGap)
        try container.encodeIfPresent(font, forKey: .font)
        try container.encodeIfPresent(title, forKey: .title)
        try container.encodeIfPresent(uniformText, forKey: .uniformText)
        try container.encodeIfPresent(autoSize, forKey: .autoSize)
        try container.encodeIfPresent(width, forKey: .width)
        try container.encodeIfPresent(height, forKey: .height)
        try container.encodeIfPresent(margin, forKey: .margin)
        try container.encodeIfPresent(computed, forKey: .computed)
        try container.encodeIfPresent(paperBackgroundColor, forKey: .paperBackgroundColor)
        try container.encodeIfPresent(plotBackgroundColor, forKey: .plotBackgroundColor)
        try container.encodeIfPresent(autoTypeNumbers, forKey: .autoTypeNumbers)
        try container.encodeIfPresent(separators, forKey: .separators)
        try container.encodeIfPresent(hideSources, forKey: .hideSources)
        try container.encodeIfPresent(showLegend, forKey: .showLegend)
        try container.encodeIfPresent(colorWay, forKey: .colorWay)
        try container.encodeIfPresent(dataRevision, forKey: .dataRevision)
        try container.encodeIfPresent(uiRevision, forKey: .uiRevision)
        try container.encodeIfPresent(editRevision, forKey: .editRevision)
        try container.encodeIfPresent(selectionRevision, forKey: .selectionRevision)
        try container.encodeIfPresent(template, forKey: .template)
        try container.encodeIfPresent(modeBar, forKey: .modeBar)
        try container.encodeIfPresent(newShape, forKey: .newShape)
        try container.encodeIfPresent(activeShape, forKey: .activeShape)
        try container.encodeIfPresent(meta, forKey: .meta)
        try container.encodeIfPresent(transition, forKey: .transition)
        try container.encodeIfPresent(clickMode, forKey: .clickMode)
        try container.encodeIfPresent(dragMode, forKey: .dragMode)
        try container.encodeIfPresent(hoverMode, forKey: .hoverMode)
        try container.encodeIfPresent(hoverDistance, forKey: .hoverDistance)
        try container.encodeIfPresent(spikeDistance, forKey: .spikeDistance)
        try container.encodeIfPresent(hoverLabel, forKey: .hoverLabel)
        try container.encodeIfPresent(selectDirection, forKey: .selectDirection)
        try container.encodeIfPresent(grid, forKey: .grid)
        try container.encodeIfPresent(calendar, forKey: .calendar)
        for axis in self.xAxis {
            try axisContainer.encode(axis, forKey: AxisKeys(.xAxis, axis.uid))
        }
        for axis in self.yAxis {
            try axisContainer.encode(axis, forKey: AxisKeys(.yAxis, axis.uid))
        }
        for axis in self.ternary {
            try axisContainer.encode(axis, forKey: AxisKeys(.ternary, axis.uid))
        }
        for axis in self.scene {
            try axisContainer.encode(axis, forKey: AxisKeys(.scene, axis.uid))
        }
        for axis in self.geo {
            try axisContainer.encode(axis, forKey: AxisKeys(.geo, axis.uid))
        }
        for axis in self.mapbox {
            try axisContainer.encode(axis, forKey: AxisKeys(.mapbox, axis.uid))
        }
        for axis in self.polar {
            try axisContainer.encode(axis, forKey: AxisKeys(.polar, axis.uid))
        }
        try container.encodeIfPresent(legend, forKey: .legend)
        try container.encodeIfPresent(annotations, forKey: .annotations)
        try container.encodeIfPresent(shapes, forKey: .shapes)
        try container.encodeIfPresent(images, forKey: .images)
        try container.encodeIfPresent(updateMenus, forKey: .updateMenus)
        try container.encodeIfPresent(sliders, forKey: .sliders)
        try container.encodeIfPresent(colorScale, forKey: .colorScale)
        for axis in self.colorAxis {
            try axisContainer.encode(axis, forKey: AxisKeys(.colorAxis, axis.uid))
        }
        /// Convenience type that appends integer UID to a coding key.
        struct AxisKeys: CodingKey {
            var intValue: Int?
            var stringValue: String
        
            init(intValue: Int) {
                self.intValue = intValue
                self.stringValue = String(intValue)
            }
        
            init(stringValue: String) {
                self.stringValue = stringValue
            }
        
            init(_ key: CodingKeys, _ uid: UInt) {
                self.init(stringValue: key.rawValue + String(uid))
            }
        }
    }
}

// MARK: - Subplot Array Extensions
extension Array where Element == XAxis {
    /// Preset default axis' customized with the most frequently used properties.
    /// 
    /// - Parameters:
    ///   - title:
    ///   - range: Sets the range of this axis.
    ///   - ticks: Determines whether ticks are drawn or not.
    ///   - tickAngle: Sets the angle of the tick labels with respect to the horizontal.
    ///   - showGrid: Determines whether or not grid lines are drawn.
    ///   - domain: Sets the domain of this axis (in plot fraction).
    public static func preset(title: XAxis.Title? = nil, range: InfoArray? = nil, ticks: Ticks? =
            nil, tickAngle: Angle? = nil, showGrid: Bool? = nil, domain: InfoArray? = nil) -> [XAxis] {
        let axis = XAxis(uid: 1)
        axis.title = title
        axis.range = range
        axis.ticks = ticks
        axis.tickAngle = tickAngle
        axis.showGrid = showGrid
        axis.domain = domain
        return [axis]
    }

    /// Preset default axis' customized with the specified properties.
    /// 
    /// - Parameters:
    ///   - visible: A single toggle to hide the axis while preserving interaction like dragging.
    ///   - color: Sets default for all colors associated with this axis all at once: line, font, tick,
    ///   and grid colors.
    ///   - title:
    ///   - type: Sets the axis type.
    ///   - autoTypeNumbers: Using *strict* a numeric string in trace data is not converted to a number.
    ///   - autoRange: Determines whether or not the range of this axis is computed in relation to the
    ///   input data.
    ///   - rangeMode: If *normal*, the range is computed in relation to the extrema of the input data.
    ///   - range: Sets the range of this axis.
    ///   - fixedRange: Determines whether or not this axis is zoom-able.
    ///   - scaleAnchor: If set to another axis id (e.g.
    ///   - scaleRatio: If this axis is linked to another by `scaleanchor`, this determines the pixel to
    ///   unit scale ratio.
    ///   - constrain: If this axis needs to be compressed (either due to its own `scaleanchor` and
    ///   `scaleratio` or those of the other axis), determines how that happens: by increasing the
    ///   *range*, or by decreasing the *domain*.
    ///   - constrainToward: If this axis needs to be compressed (either due to its own `scaleanchor` and
    ///   `scaleratio` or those of the other axis), determines which direction we push the originally
    ///   specified plot area.
    ///   - matches: If set to another axis id (e.g.
    ///   - rangeBreaks:
    ///   - tickMode: Sets the tick mode for this axis.
    ///   - numTicks: Specifies the maximum number of ticks for the particular axis.
    ///   - tick0: Sets the placement of the first tick on this axis.
    ///   - dTick: Sets the step in-between ticks on this axis.
    ///   - tickValues: Sets the values at which ticks on this axis appear.
    ///   - tickText: Sets the text displayed at the ticks position via `tickvals`.
    ///   - ticks: Determines whether ticks are drawn or not.
    ///   - ticksOn: Determines where ticks and grid lines are drawn with respect to their corresponding
    ///   tick labels.
    ///   - tickLabelMode: Determines where tick labels are drawn with respect to their corresponding
    ///   ticks and grid lines.
    ///   - tickLabelPosition: Determines where tick labels are drawn with respect to the axis Please note
    ///   that top or bottom has no effect on x axes or when `ticklabelmode` is set to *period*.
    ///   - mirror: Determines if the axis lines or/and ticks are mirrored to the opposite side of the
    ///   plotting area.
    ///   - tickLength: Sets the tick length (in px).
    ///   - tickWidth: Sets the tick width (in px).
    ///   - tickColor: Sets the tick color.
    ///   - showTickLabels: Determines whether or not the tick labels are drawn.
    ///   - autoMargin: Determines whether long tick labels automatically grow the figure margins.
    ///   - showSpikes: Determines whether or not spikes (aka droplines) are drawn for this axis.
    ///   - spikeColor: Sets the spike color.
    ///   - spikeThickness: Sets the width (in px) of the zero line.
    ///   - spikeDash: Sets the dash style of lines.
    ///   - spikeMode: Determines the drawing mode for the spike line If *toaxis*, the line is drawn from
    ///   the data point to the axis the series is plotted on.
    ///   - spikeSnap: Determines whether spikelines are stuck to the cursor or to the closest datapoints.
    ///   - tickFont: Sets the tick font.
    ///   - tickAngle: Sets the angle of the tick labels with respect to the horizontal.
    ///   - tickPrefix: Sets a tick label prefix.
    ///   - showTickPrefix: If *all*, all tick labels are displayed with a prefix.
    ///   - tickSuffix: Sets a tick label suffix.
    ///   - showTickSuffix: Same as `showtickprefix` but for tick suffixes.
    ///   - showExponent: If *all*, all exponents are shown besides their significands.
    ///   - exponentFormat: Determines a formatting rule for the tick exponents.
    ///   - minExponent: Hide SI prefix for 10^n if |n| is below this number.
    ///   - separateThousands: If "true", even 4-digit integers are separated
    ///   - tickFormat: Sets the tick label formatting rule using d3 formatting mini-languages which are
    ///   very similar to those in Python.
    ///   - tickFormatStops:
    ///   - hoverFormat: Sets the hover text formatting rule using d3 formatting mini-languages which are
    ///   very similar to those in Python.
    ///   - showLine: Determines whether or not a line bounding this axis is drawn.
    ///   - lineColor: Sets the axis line color.
    ///   - lineWidth: Sets the width (in px) of the axis line.
    ///   - showGrid: Determines whether or not grid lines are drawn.
    ///   - gridColor: Sets the color of the grid lines.
    ///   - gridWidth: Sets the width (in px) of the grid lines.
    ///   - zeroLine: Determines whether or not a line is drawn at along the 0 value of this axis.
    ///   - zeroLineColor: Sets the line color of the zero line.
    ///   - zeroLineWidth: Sets the width (in px) of the zero line.
    ///   - showDividers: Determines whether or not a dividers are drawn between the category levels of
    ///   this axis.
    ///   - dividerColor: Sets the color of the dividers Only has an effect on *multicategory* axes.
    ///   - dividerWidth: Sets the width (in px) of the dividers Only has an effect on *multicategory*
    ///   axes.
    ///   - anchor: If set to an opposite-letter axis id (e.g.
    ///   - side: Determines whether a x (y) axis is positioned at the *bottom* (*left*) or *top*
    ///   (*right*) of the plotting area.
    ///   - overlaying: If set a same-letter axis id, this axis is overlaid on top of the corresponding
    ///   same-letter axis, with traces and axes visible for both axes.
    ///   - layer: Sets the layer on which this axis is displayed.
    ///   - domain: Sets the domain of this axis (in plot fraction).
    ///   - position: Sets the position of this axis in the plotting space (in normalized coordinates).
    ///   - categoryOrder: Specifies the ordering logic for the case of categorical variables.
    ///   - categoryArray: Sets the order in which categories on this axis appear.
    ///   - uiRevision: Controls persistence of user-driven changes in axis `range`, `autorange`, and
    ///   `title` if in `editable: true` configuration.
    ///   - rangeSlider:
    ///   - rangeSelector:
    ///   - calendar: Sets the calendar system to use for `range` and `tick0` if this is a date axis.
    public static func preset(visible: Bool? = nil, color: Color? = nil, title: XAxis.Title? = nil,
            type: XAxis.`Type`? = nil, autoTypeNumbers: AutoTypeNumbers? = nil, autoRange: AutoRange? = nil,
            rangeMode: RangeMode? = nil, range: InfoArray? = nil, fixedRange: Bool? = nil, scaleAnchor:
            XAxis.ScaleAnchor? = nil, scaleRatio: Double? = nil, constrain: XAxis.Constrain? = nil,
            constrainToward: XAxis.ConstrainToward? = nil, matches: XAxis.Matches? = nil, rangeBreaks:
            [XAxis.RangeBreak]? = nil, tickMode: TickMode? = nil, numTicks: Int? = nil, tick0: Anything? =
            nil, dTick: Anything? = nil, tickValues: [Double]? = nil, tickText: [Double]? = nil, ticks:
            Ticks? = nil, ticksOn: XAxis.TicksOn? = nil, tickLabelMode: XAxis.TickLabelMode? = nil,
            tickLabelPosition: XAxis.TickLabelPosition? = nil, mirror: Mirror? = nil, tickLength: Double? =
            nil, tickWidth: Double? = nil, tickColor: Color? = nil, showTickLabels: Bool? = nil, autoMargin:
            Bool? = nil, showSpikes: Bool? = nil, spikeColor: Color? = nil, spikeThickness: Double? = nil,
            spikeDash: String? = nil, spikeMode: XAxis.SpikeMode? = nil, spikeSnap: XAxis.SpikeSnap? = nil,
            tickFont: Font? = nil, tickAngle: Angle? = nil, tickPrefix: String? = nil, showTickPrefix:
            ShowTickPrefix? = nil, tickSuffix: String? = nil, showTickSuffix: ShowTickSuffix? = nil,
            showExponent: ShowExponent? = nil, exponentFormat: ExponentFormat? = nil, minExponent: Double? =
            nil, separateThousands: Bool? = nil, tickFormat: String? = nil, tickFormatStops:
            [TickFormatStop]? = nil, hoverFormat: String? = nil, showLine: Bool? = nil, lineColor: Color? =
            nil, lineWidth: Double? = nil, showGrid: Bool? = nil, gridColor: Color? = nil, gridWidth:
            Double? = nil, zeroLine: Bool? = nil, zeroLineColor: Color? = nil, zeroLineWidth: Double? = nil,
            showDividers: Bool? = nil, dividerColor: Color? = nil, dividerWidth: Double? = nil, anchor:
            XAxis.Anchor? = nil, side: XAxis.Side? = nil, overlaying: XAxis.Overlaying? = nil, layer:
            AxisLayer? = nil, domain: InfoArray? = nil, position: Double? = nil, categoryOrder:
            CategoryOrder? = nil, categoryArray: [Double]? = nil, uiRevision: Anything? = nil, rangeSlider:
            XAxis.RangeSlider? = nil, rangeSelector: XAxis.RangeSelector? = nil, calendar: Calendar? = nil)
            -> [XAxis] {
        let axis = XAxis(uid: 1)
        axis.visible = visible
        axis.color = color
        axis.title = title
        axis.type = type
        axis.autoTypeNumbers = autoTypeNumbers
        axis.autoRange = autoRange
        axis.rangeMode = rangeMode
        axis.range = range
        axis.fixedRange = fixedRange
        axis.scaleAnchor = scaleAnchor
        axis.scaleRatio = scaleRatio
        axis.constrain = constrain
        axis.constrainToward = constrainToward
        axis.matches = matches
        axis.rangeBreaks = rangeBreaks
        axis.tickMode = tickMode
        axis.numTicks = numTicks
        axis.tick0 = tick0
        axis.dTick = dTick
        axis.tickValues = tickValues
        axis.tickText = tickText
        axis.ticks = ticks
        axis.ticksOn = ticksOn
        axis.tickLabelMode = tickLabelMode
        axis.tickLabelPosition = tickLabelPosition
        axis.mirror = mirror
        axis.tickLength = tickLength
        axis.tickWidth = tickWidth
        axis.tickColor = tickColor
        axis.showTickLabels = showTickLabels
        axis.autoMargin = autoMargin
        axis.showSpikes = showSpikes
        axis.spikeColor = spikeColor
        axis.spikeThickness = spikeThickness
        axis.spikeDash = spikeDash
        axis.spikeMode = spikeMode
        axis.spikeSnap = spikeSnap
        axis.tickFont = tickFont
        axis.tickAngle = tickAngle
        axis.tickPrefix = tickPrefix
        axis.showTickPrefix = showTickPrefix
        axis.tickSuffix = tickSuffix
        axis.showTickSuffix = showTickSuffix
        axis.showExponent = showExponent
        axis.exponentFormat = exponentFormat
        axis.minExponent = minExponent
        axis.separateThousands = separateThousands
        axis.tickFormat = tickFormat
        axis.tickFormatStops = tickFormatStops
        axis.hoverFormat = hoverFormat
        axis.showLine = showLine
        axis.lineColor = lineColor
        axis.lineWidth = lineWidth
        axis.showGrid = showGrid
        axis.gridColor = gridColor
        axis.gridWidth = gridWidth
        axis.zeroLine = zeroLine
        axis.zeroLineColor = zeroLineColor
        axis.zeroLineWidth = zeroLineWidth
        axis.showDividers = showDividers
        axis.dividerColor = dividerColor
        axis.dividerWidth = dividerWidth
        axis.anchor = anchor
        axis.side = side
        axis.overlaying = overlaying
        axis.layer = layer
        axis.domain = domain
        axis.position = position
        axis.categoryOrder = categoryOrder
        axis.categoryArray = categoryArray
        axis.uiRevision = uiRevision
        axis.rangeSlider = rangeSlider
        axis.rangeSelector = rangeSelector
        axis.calendar = calendar
        return [axis]
    }
}

extension Array where Element == YAxis {
    /// Preset default axis' customized with the most frequently used properties.
    /// 
    /// - Parameters:
    ///   - title:
    ///   - range: Sets the range of this axis.
    ///   - ticks: Determines whether ticks are drawn or not.
    ///   - tickAngle: Sets the angle of the tick labels with respect to the horizontal.
    ///   - showGrid: Determines whether or not grid lines are drawn.
    ///   - domain: Sets the domain of this axis (in plot fraction).
    public static func preset(title: YAxis.Title? = nil, range: InfoArray? = nil, ticks: Ticks? =
            nil, tickAngle: Angle? = nil, showGrid: Bool? = nil, domain: InfoArray? = nil) -> [YAxis] {
        let axis = YAxis(uid: 1)
        axis.title = title
        axis.range = range
        axis.ticks = ticks
        axis.tickAngle = tickAngle
        axis.showGrid = showGrid
        axis.domain = domain
        return [axis]
    }

    /// Preset default axis' customized with the specified properties.
    /// 
    /// - Parameters:
    ///   - visible: A single toggle to hide the axis while preserving interaction like dragging.
    ///   - color: Sets default for all colors associated with this axis all at once: line, font, tick,
    ///   and grid colors.
    ///   - title:
    ///   - type: Sets the axis type.
    ///   - autoTypeNumbers: Using *strict* a numeric string in trace data is not converted to a number.
    ///   - autoRange: Determines whether or not the range of this axis is computed in relation to the
    ///   input data.
    ///   - rangeMode: If *normal*, the range is computed in relation to the extrema of the input data.
    ///   - range: Sets the range of this axis.
    ///   - fixedRange: Determines whether or not this axis is zoom-able.
    ///   - scaleAnchor: If set to another axis id (e.g.
    ///   - scaleRatio: If this axis is linked to another by `scaleanchor`, this determines the pixel to
    ///   unit scale ratio.
    ///   - constrain: If this axis needs to be compressed (either due to its own `scaleanchor` and
    ///   `scaleratio` or those of the other axis), determines how that happens: by increasing the
    ///   *range*, or by decreasing the *domain*.
    ///   - constrainToward: If this axis needs to be compressed (either due to its own `scaleanchor` and
    ///   `scaleratio` or those of the other axis), determines which direction we push the originally
    ///   specified plot area.
    ///   - matches: If set to another axis id (e.g.
    ///   - rangeBreaks:
    ///   - tickMode: Sets the tick mode for this axis.
    ///   - numTicks: Specifies the maximum number of ticks for the particular axis.
    ///   - tick0: Sets the placement of the first tick on this axis.
    ///   - dTick: Sets the step in-between ticks on this axis.
    ///   - tickValues: Sets the values at which ticks on this axis appear.
    ///   - tickText: Sets the text displayed at the ticks position via `tickvals`.
    ///   - ticks: Determines whether ticks are drawn or not.
    ///   - ticksOn: Determines where ticks and grid lines are drawn with respect to their corresponding
    ///   tick labels.
    ///   - tickLabelMode: Determines where tick labels are drawn with respect to their corresponding
    ///   ticks and grid lines.
    ///   - tickLabelPosition: Determines where tick labels are drawn with respect to the axis Please note
    ///   that top or bottom has no effect on x axes or when `ticklabelmode` is set to *period*.
    ///   - mirror: Determines if the axis lines or/and ticks are mirrored to the opposite side of the
    ///   plotting area.
    ///   - tickLength: Sets the tick length (in px).
    ///   - tickWidth: Sets the tick width (in px).
    ///   - tickColor: Sets the tick color.
    ///   - showTickLabels: Determines whether or not the tick labels are drawn.
    ///   - autoMargin: Determines whether long tick labels automatically grow the figure margins.
    ///   - showSpikes: Determines whether or not spikes (aka droplines) are drawn for this axis.
    ///   - spikeColor: Sets the spike color.
    ///   - spikeThickness: Sets the width (in px) of the zero line.
    ///   - spikeDash: Sets the dash style of lines.
    ///   - spikeMode: Determines the drawing mode for the spike line If *toaxis*, the line is drawn from
    ///   the data point to the axis the series is plotted on.
    ///   - spikeSnap: Determines whether spikelines are stuck to the cursor or to the closest datapoints.
    ///   - tickFont: Sets the tick font.
    ///   - tickAngle: Sets the angle of the tick labels with respect to the horizontal.
    ///   - tickPrefix: Sets a tick label prefix.
    ///   - showTickPrefix: If *all*, all tick labels are displayed with a prefix.
    ///   - tickSuffix: Sets a tick label suffix.
    ///   - showTickSuffix: Same as `showtickprefix` but for tick suffixes.
    ///   - showExponent: If *all*, all exponents are shown besides their significands.
    ///   - exponentFormat: Determines a formatting rule for the tick exponents.
    ///   - minExponent: Hide SI prefix for 10^n if |n| is below this number.
    ///   - separateThousands: If "true", even 4-digit integers are separated
    ///   - tickFormat: Sets the tick label formatting rule using d3 formatting mini-languages which are
    ///   very similar to those in Python.
    ///   - tickFormatStops:
    ///   - hoverFormat: Sets the hover text formatting rule using d3 formatting mini-languages which are
    ///   very similar to those in Python.
    ///   - showLine: Determines whether or not a line bounding this axis is drawn.
    ///   - lineColor: Sets the axis line color.
    ///   - lineWidth: Sets the width (in px) of the axis line.
    ///   - showGrid: Determines whether or not grid lines are drawn.
    ///   - gridColor: Sets the color of the grid lines.
    ///   - gridWidth: Sets the width (in px) of the grid lines.
    ///   - zeroLine: Determines whether or not a line is drawn at along the 0 value of this axis.
    ///   - zeroLineColor: Sets the line color of the zero line.
    ///   - zeroLineWidth: Sets the width (in px) of the zero line.
    ///   - showDividers: Determines whether or not a dividers are drawn between the category levels of
    ///   this axis.
    ///   - dividerColor: Sets the color of the dividers Only has an effect on *multicategory* axes.
    ///   - dividerWidth: Sets the width (in px) of the dividers Only has an effect on *multicategory*
    ///   axes.
    ///   - anchor: If set to an opposite-letter axis id (e.g.
    ///   - side: Determines whether a x (y) axis is positioned at the *bottom* (*left*) or *top*
    ///   (*right*) of the plotting area.
    ///   - overlaying: If set a same-letter axis id, this axis is overlaid on top of the corresponding
    ///   same-letter axis, with traces and axes visible for both axes.
    ///   - layer: Sets the layer on which this axis is displayed.
    ///   - domain: Sets the domain of this axis (in plot fraction).
    ///   - position: Sets the position of this axis in the plotting space (in normalized coordinates).
    ///   - categoryOrder: Specifies the ordering logic for the case of categorical variables.
    ///   - categoryArray: Sets the order in which categories on this axis appear.
    ///   - uiRevision: Controls persistence of user-driven changes in axis `range`, `autorange`, and
    ///   `title` if in `editable: true` configuration.
    ///   - calendar: Sets the calendar system to use for `range` and `tick0` if this is a date axis.
    public static func preset(visible: Bool? = nil, color: Color? = nil, title: YAxis.Title? = nil,
            type: YAxis.`Type`? = nil, autoTypeNumbers: AutoTypeNumbers? = nil, autoRange: AutoRange? = nil,
            rangeMode: RangeMode? = nil, range: InfoArray? = nil, fixedRange: Bool? = nil, scaleAnchor:
            YAxis.ScaleAnchor? = nil, scaleRatio: Double? = nil, constrain: YAxis.Constrain? = nil,
            constrainToward: YAxis.ConstrainToward? = nil, matches: YAxis.Matches? = nil, rangeBreaks:
            [YAxis.RangeBreak]? = nil, tickMode: TickMode? = nil, numTicks: Int? = nil, tick0: Anything? =
            nil, dTick: Anything? = nil, tickValues: [Double]? = nil, tickText: [Double]? = nil, ticks:
            Ticks? = nil, ticksOn: YAxis.TicksOn? = nil, tickLabelMode: YAxis.TickLabelMode? = nil,
            tickLabelPosition: YAxis.TickLabelPosition? = nil, mirror: Mirror? = nil, tickLength: Double? =
            nil, tickWidth: Double? = nil, tickColor: Color? = nil, showTickLabels: Bool? = nil, autoMargin:
            Bool? = nil, showSpikes: Bool? = nil, spikeColor: Color? = nil, spikeThickness: Double? = nil,
            spikeDash: String? = nil, spikeMode: YAxis.SpikeMode? = nil, spikeSnap: YAxis.SpikeSnap? = nil,
            tickFont: Font? = nil, tickAngle: Angle? = nil, tickPrefix: String? = nil, showTickPrefix:
            ShowTickPrefix? = nil, tickSuffix: String? = nil, showTickSuffix: ShowTickSuffix? = nil,
            showExponent: ShowExponent? = nil, exponentFormat: ExponentFormat? = nil, minExponent: Double? =
            nil, separateThousands: Bool? = nil, tickFormat: String? = nil, tickFormatStops:
            [TickFormatStop]? = nil, hoverFormat: String? = nil, showLine: Bool? = nil, lineColor: Color? =
            nil, lineWidth: Double? = nil, showGrid: Bool? = nil, gridColor: Color? = nil, gridWidth:
            Double? = nil, zeroLine: Bool? = nil, zeroLineColor: Color? = nil, zeroLineWidth: Double? = nil,
            showDividers: Bool? = nil, dividerColor: Color? = nil, dividerWidth: Double? = nil, anchor:
            YAxis.Anchor? = nil, side: YAxis.Side? = nil, overlaying: YAxis.Overlaying? = nil, layer:
            AxisLayer? = nil, domain: InfoArray? = nil, position: Double? = nil, categoryOrder:
            CategoryOrder? = nil, categoryArray: [Double]? = nil, uiRevision: Anything? = nil, calendar:
            Calendar? = nil) -> [YAxis] {
        let axis = YAxis(uid: 1)
        axis.visible = visible
        axis.color = color
        axis.title = title
        axis.type = type
        axis.autoTypeNumbers = autoTypeNumbers
        axis.autoRange = autoRange
        axis.rangeMode = rangeMode
        axis.range = range
        axis.fixedRange = fixedRange
        axis.scaleAnchor = scaleAnchor
        axis.scaleRatio = scaleRatio
        axis.constrain = constrain
        axis.constrainToward = constrainToward
        axis.matches = matches
        axis.rangeBreaks = rangeBreaks
        axis.tickMode = tickMode
        axis.numTicks = numTicks
        axis.tick0 = tick0
        axis.dTick = dTick
        axis.tickValues = tickValues
        axis.tickText = tickText
        axis.ticks = ticks
        axis.ticksOn = ticksOn
        axis.tickLabelMode = tickLabelMode
        axis.tickLabelPosition = tickLabelPosition
        axis.mirror = mirror
        axis.tickLength = tickLength
        axis.tickWidth = tickWidth
        axis.tickColor = tickColor
        axis.showTickLabels = showTickLabels
        axis.autoMargin = autoMargin
        axis.showSpikes = showSpikes
        axis.spikeColor = spikeColor
        axis.spikeThickness = spikeThickness
        axis.spikeDash = spikeDash
        axis.spikeMode = spikeMode
        axis.spikeSnap = spikeSnap
        axis.tickFont = tickFont
        axis.tickAngle = tickAngle
        axis.tickPrefix = tickPrefix
        axis.showTickPrefix = showTickPrefix
        axis.tickSuffix = tickSuffix
        axis.showTickSuffix = showTickSuffix
        axis.showExponent = showExponent
        axis.exponentFormat = exponentFormat
        axis.minExponent = minExponent
        axis.separateThousands = separateThousands
        axis.tickFormat = tickFormat
        axis.tickFormatStops = tickFormatStops
        axis.hoverFormat = hoverFormat
        axis.showLine = showLine
        axis.lineColor = lineColor
        axis.lineWidth = lineWidth
        axis.showGrid = showGrid
        axis.gridColor = gridColor
        axis.gridWidth = gridWidth
        axis.zeroLine = zeroLine
        axis.zeroLineColor = zeroLineColor
        axis.zeroLineWidth = zeroLineWidth
        axis.showDividers = showDividers
        axis.dividerColor = dividerColor
        axis.dividerWidth = dividerWidth
        axis.anchor = anchor
        axis.side = side
        axis.overlaying = overlaying
        axis.layer = layer
        axis.domain = domain
        axis.position = position
        axis.categoryOrder = categoryOrder
        axis.categoryArray = categoryArray
        axis.uiRevision = uiRevision
        axis.calendar = calendar
        return [axis]
    }
}

extension Array where Element == Ternary {

    /// Preset default axis' customized with the specified properties.
    /// 
    /// - Parameters:
    ///   - domain:
    ///   - backgroundColor: Set the background color of the subplot
    ///   - sum: The number each triplet should sum to, and the maximum range of each axis
    ///   - aAxis:
    ///   - bAxis:
    ///   - cAxis:
    ///   - uiRevision: Controls persistence of user-driven changes in axis `min` and `title`, if not
    ///   overridden in the individual axes.
    public static func preset(domain: Domain? = nil, backgroundColor: Color? = nil, sum: Double? =
            nil, aAxis: Ternary.AAxis? = nil, bAxis: Ternary.BAxis? = nil, cAxis: Ternary.CAxis? = nil,
            uiRevision: Anything? = nil) -> [Ternary] {
        let axis = Ternary(uid: 1)
        axis.domain = domain
        axis.backgroundColor = backgroundColor
        axis.sum = sum
        axis.aAxis = aAxis
        axis.bAxis = bAxis
        axis.cAxis = cAxis
        axis.uiRevision = uiRevision
        return [axis]
    }
}

extension Array where Element == Scene {

    /// Preset default axis' customized with the specified properties.
    /// 
    /// - Parameters:
    ///   - backgroundColor:
    ///   - camera:
    ///   - domain:
    ///   - aspectMode: If *cube*, this scene's axes are drawn as a cube, regardless of the axes' ranges.
    ///   - aspectRatio: Sets this scene's axis aspectratio.
    ///   - xAxis:
    ///   - yAxis:
    ///   - zAxis:
    ///   - dragMode: Determines the mode of drag interactions for this scene.
    ///   - hoverMode: Determines the mode of hover interactions for this scene.
    ///   - uiRevision: Controls persistence of user-driven changes in camera attributes.
    ///   - annotations:
    public static func preset(backgroundColor: Color? = nil, camera: Scene.Camera? = nil, domain:
            Domain? = nil, aspectMode: Scene.AspectMode? = nil, aspectRatio: Scene.AspectRatio? = nil,
            xAxis: Scene.XAxis? = nil, yAxis: Scene.YAxis? = nil, zAxis: Scene.ZAxis? = nil, dragMode:
            Scene.DragMode? = nil, hoverMode: Scene.HoverMode? = nil, uiRevision: Anything? = nil,
            annotations: [Scene.Annotation]? = nil) -> [Scene] {
        let axis = Scene(uid: 1)
        axis.backgroundColor = backgroundColor
        axis.camera = camera
        axis.domain = domain
        axis.aspectMode = aspectMode
        axis.aspectRatio = aspectRatio
        axis.xAxis = xAxis
        axis.yAxis = yAxis
        axis.zAxis = zAxis
        axis.dragMode = dragMode
        axis.hoverMode = hoverMode
        axis.uiRevision = uiRevision
        axis.annotations = annotations
        return [axis]
    }
}

extension Array where Element == Geo {

    /// Preset default axis' customized with the specified properties.
    /// 
    /// - Parameters:
    ///   - domain:
    ///   - fitBounds: Determines if this subplot's view settings are auto-computed to fit trace data.
    ///   - resolution: Sets the resolution of the base layers.
    ///   - scope: Set the scope of the map.
    ///   - projection:
    ///   - center:
    ///   - visible: Sets the default visibility of the base layers.
    ///   - showCoastLines: Sets whether or not the coastlines are drawn.
    ///   - coastLineColor: Sets the coastline color.
    ///   - coastLineWidth: Sets the coastline stroke width (in px).
    ///   - showLand: Sets whether or not land masses are filled in color.
    ///   - landColor: Sets the land mass color.
    ///   - showOcean: Sets whether or not oceans are filled in color.
    ///   - oceanColor: Sets the ocean color
    ///   - showLakes: Sets whether or not lakes are drawn.
    ///   - lakeColor: Sets the color of the lakes.
    ///   - showRivers: Sets whether or not rivers are drawn.
    ///   - riverColor: Sets color of the rivers.
    ///   - riverWidth: Sets the stroke width (in px) of the rivers.
    ///   - showCountries: Sets whether or not country boundaries are drawn.
    ///   - countryColor: Sets line color of the country boundaries.
    ///   - countryWidth: Sets line width (in px) of the country boundaries.
    ///   - showSubunits: Sets whether or not boundaries of subunits within countries (e.g.
    ///   - subUnitColor: Sets the color of the subunits boundaries.
    ///   - subUnitWidth: Sets the stroke width (in px) of the subunits boundaries.
    ///   - showFrame: Sets whether or not a frame is drawn around the map.
    ///   - frameColor: Sets the color the frame.
    ///   - frameWidth: Sets the stroke width (in px) of the frame.
    ///   - backgroundColor: Set the background color of the map
    ///   - longitudeAxis:
    ///   - latitudeAxis:
    ///   - uiRevision: Controls persistence of user-driven changes in the view (projection and center).
    public static func preset(domain: Domain? = nil, fitBounds: Geo.FitBounds? = nil, resolution:
            Geo.Resolution? = nil, scope: Geo.Scope? = nil, projection: Geo.Projection? = nil, center:
            Geo.Center? = nil, visible: Bool? = nil, showCoastLines: Bool? = nil, coastLineColor: Color? =
            nil, coastLineWidth: Double? = nil, showLand: Bool? = nil, landColor: Color? = nil, showOcean:
            Bool? = nil, oceanColor: Color? = nil, showLakes: Bool? = nil, lakeColor: Color? = nil,
            showRivers: Bool? = nil, riverColor: Color? = nil, riverWidth: Double? = nil, showCountries:
            Bool? = nil, countryColor: Color? = nil, countryWidth: Double? = nil, showSubunits: Bool? = nil,
            subUnitColor: Color? = nil, subUnitWidth: Double? = nil, showFrame: Bool? = nil, frameColor:
            Color? = nil, frameWidth: Double? = nil, backgroundColor: Color? = nil, longitudeAxis:
            Geo.LongitudeAxis? = nil, latitudeAxis: Geo.LatitudeAxis? = nil, uiRevision: Anything? = nil) ->
            [Geo] {
        let axis = Geo(uid: 1)
        axis.domain = domain
        axis.fitBounds = fitBounds
        axis.resolution = resolution
        axis.scope = scope
        axis.projection = projection
        axis.center = center
        axis.visible = visible
        axis.showCoastLines = showCoastLines
        axis.coastLineColor = coastLineColor
        axis.coastLineWidth = coastLineWidth
        axis.showLand = showLand
        axis.landColor = landColor
        axis.showOcean = showOcean
        axis.oceanColor = oceanColor
        axis.showLakes = showLakes
        axis.lakeColor = lakeColor
        axis.showRivers = showRivers
        axis.riverColor = riverColor
        axis.riverWidth = riverWidth
        axis.showCountries = showCountries
        axis.countryColor = countryColor
        axis.countryWidth = countryWidth
        axis.showSubunits = showSubunits
        axis.subUnitColor = subUnitColor
        axis.subUnitWidth = subUnitWidth
        axis.showFrame = showFrame
        axis.frameColor = frameColor
        axis.frameWidth = frameWidth
        axis.backgroundColor = backgroundColor
        axis.longitudeAxis = longitudeAxis
        axis.latitudeAxis = latitudeAxis
        axis.uiRevision = uiRevision
        return [axis]
    }
}

extension Array where Element == Mapbox {

    /// Preset default axis' customized with the specified properties.
    /// 
    /// - Parameters:
    ///   - domain:
    ///   - accessToken: Sets the mapbox access token to be used for this mapbox map.
    ///   - style: Defines the map layers that are rendered by default below the trace layers defined in
    ///   `data`, which are themselves by default rendered below the layers defined in
    ///   `layout.mapbox.layers`.
    ///   - center:
    ///   - zoom: Sets the zoom level of the map (mapbox.zoom).
    ///   - bearing: Sets the bearing angle of the map in degrees counter-clockwise from North
    ///   (mapbox.bearing).
    ///   - pitch: Sets the pitch angle of the map (in degrees, where *0* means perpendicular to the
    ///   surface of the map) (mapbox.pitch).
    ///   - layers:
    ///   - uiRevision: Controls persistence of user-driven changes in the view: `center`, `zoom`,
    ///   `bearing`, `pitch`.
    public static func preset(domain: Domain? = nil, accessToken: String? = nil, style: Anything? =
            nil, center: Mapbox.Center? = nil, zoom: Double? = nil, bearing: Double? = nil, pitch: Double? =
            nil, layers: [Mapbox.Layer]? = nil, uiRevision: Anything? = nil) -> [Mapbox] {
        let axis = Mapbox(uid: 1)
        axis.domain = domain
        axis.accessToken = accessToken
        axis.style = style
        axis.center = center
        axis.zoom = zoom
        axis.bearing = bearing
        axis.pitch = pitch
        axis.layers = layers
        axis.uiRevision = uiRevision
        return [axis]
    }
}

extension Array where Element == Polar {

    /// Preset default axis' customized with the specified properties.
    /// 
    /// - Parameters:
    ///   - domain:
    ///   - sector: Sets angular span of this polar subplot with two angles (in degrees).
    ///   - hole: Sets the fraction of the radius to cut out of the polar subplot.
    ///   - backgroundColor: Set the background color of the subplot
    ///   - radialAxis:
    ///   - angularAxis:
    ///   - gridShape: Determines if the radial axis grid lines and angular axis line are drawn as
    ///   *circular* sectors or as *linear* (polygon) sectors.
    ///   - uiRevision: Controls persistence of user-driven changes in axis attributes, if not overridden
    ///   in the individual axes.
    public static func preset(domain: Domain? = nil, sector: InfoArray? = nil, hole: Double? = nil,
            backgroundColor: Color? = nil, radialAxis: Polar.RadialAxis? = nil, angularAxis:
            Polar.AngularAxis? = nil, gridShape: Polar.GridShape? = nil, uiRevision: Anything? = nil) ->
            [Polar] {
        let axis = Polar(uid: 1)
        axis.domain = domain
        axis.sector = sector
        axis.hole = hole
        axis.backgroundColor = backgroundColor
        axis.radialAxis = radialAxis
        axis.angularAxis = angularAxis
        axis.gridShape = gridShape
        axis.uiRevision = uiRevision
        return [axis]
    }
}

extension Array where Element == ColorAxis {

    /// Preset default axis' customized with the specified properties.
    /// 
    /// - Parameters:
    ///   - cAuto: Determines whether or not the color domain is computed with respect to the input data
    ///   (here corresponding trace color array(s)) or the bounds set in `cmin` and `cmax` Defaults to
    ///   `false` when `cmin` and `cmax` are set by the user.
    ///   - cMin: Sets the lower bound of the color domain.
    ///   - cMax: Sets the upper bound of the color domain.
    ///   - cMiddle: Sets the mid-point of the color domain by scaling `cmin` and/or `cmax` to be
    ///   equidistant to this point.
    ///   - colorScale: Sets the colorscale.
    ///   - autoColorScale: Determines whether the colorscale is a default palette (`autocolorscale:
    ///   true`) or the palette determined by `colorscale`.
    ///   - reverseScale: Reverses the color mapping if true.
    ///   - showScale: Determines whether or not a colorbar is displayed for this trace.
    ///   - colorBar:
    public static func preset(cAuto: Bool? = nil, cMin: Double? = nil, cMax: Double? = nil, cMiddle:
            Double? = nil, colorScale: ColorScale? = nil, autoColorScale: Bool? = nil, reverseScale: Bool? =
            nil, showScale: Bool? = nil, colorBar: ColorBar? = nil) -> [ColorAxis] {
        let axis = ColorAxis(uid: 1)
        axis.cAuto = cAuto
        axis.cMin = cMin
        axis.cMax = cMax
        axis.cMiddle = cMiddle
        axis.colorScale = colorScale
        axis.autoColorScale = autoColorScale
        axis.reverseScale = reverseScale
        axis.showScale = showScale
        axis.colorBar = colorBar
        return [axis]
    }
}

